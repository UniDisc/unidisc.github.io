<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Meta tags for social media banners -->
  <meta name="description" content="UniDisc: Unified Multimodal Discrete Diffusion">
  <meta property="og:title" content="UniDisc: Unified Multimodal Discrete Diffusion"/>
  <meta property="og:description" content="UniDisc is a unified multimodal discrete diffusion model capable of jointly processing text and images for various tasks."/>
  <meta property="og:url" content="https://yourwebsite.com"/>
  <!-- Path to banner image -->
  <meta property="og:image" content="static/images/banner_image.webp" />
  <meta property="og:image:width" content="1200"/>
  <meta property="og:image:height" content="630"/>

  <meta name="twitter:title" content="UniDisc: Unified Multimodal Discrete Diffusion">
  <meta name="twitter:description" content="UniDisc is a unified multimodal discrete diffusion model capable of jointly processing text and images for various tasks.">
  <!-- Path to banner image -->
  <meta name="twitter:image" content="static/images/banner_image.webp">
  <meta name="twitter:card" content="summary_large_image">
  <!-- Keywords -->
  <meta name="keywords" content="UniDisc, Multimodal, Discrete Diffusion, Machine Learning, AI, Text Generation, Image Generation">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>UniDisc: Unified Multimodal Discrete Diffusion</title>
  <!-- <link rel="icon" type="image/x-icon" href="static/images/favicon.ico"> -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro"
  rel="stylesheet">

  <link rel="stylesheet" href="static/css/bulma.min.css">
  <link rel="stylesheet" href="static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="static/css/fontawesome.all.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="static/css/index.css">
  <style>
    .container p {
      padding-top: 1rem;
    }
    /* Add new custom column class */
    .is-five-sixths {
      flex: none;
      width: 87.5%;
    }

    html {
      scroll-behavior: smooth;
    }

    a.anchor-link {
      margin-left: 0.15em;
      color: inherit;
      text-decoration: none;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.6em;
      position: relative;
      top: -0.15em;
      cursor: pointer;
    }

    /* Show the anchor link on hover */
    h2[id]:hover a.anchor-link {
      opacity: 1;
    }

    .progressive-image-container {
      position: relative;
      overflow: hidden;
    }

    .progressive-image {
      opacity: 0;
      transition: opacity 0.3s ease-in;
    }

    .progressive-image.loaded {
      opacity: 1;
    }

    .image-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3273dc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Update the cached-sentence-builder width and layout */
    #cached-section .cached-sentence-builder {
        flex-grow: 1;
        width: 100%; /* Changed from fixed 512px to 100% */
        padding: 0px 23px; /* Keep existing padding */
        max-width: 512px; /* Add max-width that matches the grid container */
    }

    /* Update the current sentence display */
    #cached-section #cached-current-sentence {
        margin-top: 10px;
        padding: 15px;
        background-color: #f5f5f5;
        border-radius: 8px;
        min-height: 30px;
        font-family: monospace;
        width: 100%; /* Ensure it takes full width of its container */
        box-sizing: border-box; /* Include padding in width calculation */
        white-space: pre-wrap; /* Allow text to wrap */
        word-break: break-word; /* Break long words if needed */
    }

    /* Add styles for the response text */
    #cached-section #cached-response-text {
        margin-top: 8px;
        padding: 15px;
        background-color: #e6f7ff;
        border-radius: 8px;
        min-height: 30px;
        font-family: monospace;
        width: 100%;
        box-sizing: border-box;
        white-space: pre-wrap;
        word-break: break-word;
        display: block; /* Changed from none to block */
    }

    /* Adjust the main container spacing */
    #cached-section .cached-main-container {
        display: flex;
        max-width: 1050px; /* Reduced from 1200px */
        margin: 0 auto; /* Center the container */
        gap: 40px; /* Increased from 20px for more balanced spacing */
        align-items: flex-start;
        padding: 0 20px; /* Add padding to prevent edge touching */
    }

    #cached-section .cached-grid-container {
      position: relative;
      width: 512px;
      height: 512px;
    } 

    /* Add styles for the reset buttons */
    #cached-section .cached-reset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 5px;       
      margin-bottom: 15px;   
      justify-content: flex-start;
      flex-wrap: wrap;     /* Changed from nowrap to wrap to handle different screen sizes */
      overflow-x: visible; /* Changed from auto to visible since we're allowing wrapping */
      padding-bottom: 5px;
      width: 100%;         /* Added to ensure it takes full width */
    }

    #cached-section .cached-reset-button {
      padding: 8px 15px;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    #cached-section .cached-reset-button:hover {
      background-color: #e0e0e0;
    }

    /* Add styles for the grey overlay */
    #cached-section .cached-grey-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #888888; /* Solid grey color */
      z-index: 10; /* Ensure it's above the grid */
      display: none; /* Initially hidden */
    }

    /* Scoped styles for the cached section */
    #cached-section {
      font-family: Arial, sans-serif;
    }
    /* Restore bolder text for headers and word options */
    #cached-section h2,
    #cached-section .cached-word-option {
      font-weight: 700;
    }
    #cached-section .cached-main-container {
      display: flex;
      max-width: 1200px; /* Increased width to accommodate side-by-side layout */
      margin: 0 auto;
      gap: 40px;
      align-items: flex-start;
      padding: 0 20px;
    }
    /* Updated to have input and output sides */
    #cached-section .cached-side {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px; /* Reduced from 20px */
      width: 50%;
    }
    /* Left side (input) - left aligned */
    #cached-section .cached-input-side {
      align-items: flex-start;
    }
    /* Right side (output) - center aligned */
    #cached-section .cached-output-side {
      align-items: center;
    }
    #cached-section .cached-side-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 1.2rem;
      width: 100%;
    }
    #cached-section .cached-grid-container {
      position: relative;
      width: 512px;
      height: 512px;
      margin: 0 auto;
    }
    #cached-section .cached-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #cached-section .cached-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
      /* TODO: Grid define */
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
    }
    #cached-section .cached-grid-cell {
      border: 1px solid black;
      transition: background-color 0.1s ease;
    }
    #cached-section .cached-highlighted {
      background-color: rgba(128, 128, 128, 0.9);
    }
    #cached-section .cached-sentence-builder {
      width: 512px; /* Match width with image container */
      padding: 0px 23px; /* Reduced top padding from 20px to 10px */
    }
    #cached-section .cached-output-container {
      width: 512px; /* Match width with image container */
    }
    #cached-section .cached-sentence-row {
      margin: 10px 0; /* Reduced from 15px to 10px */
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: flex-start; /* Align items to the start of the row */
      width: 100%; /* Ensure the row takes full width of its container */
    }
    #cached-section .cached-word-option {
      padding: 5px 8px; /* Reduced padding from 12px 20px */
      cursor: pointer;
      transition: all 0.2s ease;
      color: #666;
      border-radius: 4px;
      font-weight: 600;
      background: #f5f5f5;
      margin-bottom: 5px; /* Add bottom margin for better spacing when wrapped */
      font-size: 0.8rem; /* Added smaller font size */
    }
    #cached-section .cached-word-option:hover {
      color: #000;
      font-weight: 600;
      background: #e5e5e5;
    }
    #cached-section .cached-word-option.cached-selected {
      color: #886a6a;
      font-weight: 600;
      background: #e0e0e0;
    }
    #cached-section .cached-text-display {
      margin-top: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 8px;
      min-height: 30px;
      font-family: monospace;
      width: 100%;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #cached-section .cached-output-display {
      margin-top: 10px;
      padding: 15px;
      background-color: #e6f7ff;
      border-radius: 8px;
      min-height: 30px;
      font-family: monospace;
      width: 100%;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #cached-section .cached-grey-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #888888;
      z-index: 10;
      display: none;
    }
    #cached-section .cached-reset-buttons {
      display: flex;
      gap: 10px;
      margin-top: 5px;       
      margin-bottom: 15px;   
      justify-content: flex-start;
      flex-wrap: nowrap;     /* Prevent wrapping */
      overflow-x: auto;      /* Allow horizontal scrolling if needed */
      padding-bottom: 5px;   /* Add space for potential scrollbar */
    }
    #cached-section .cached-reset-button {
      padding: 8px 15px;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }
    #cached-section .cached-reset-button:hover {
      background-color: #e0e0e0;
    }
    #cached-section .cached-mask-size-container {
      display: flex;
      align-items: center;
      margin-left: 10px;
    }
    #cached-section .cached-mask-size-label {
      font-size: 12px;
      margin-right: 5px;
      white-space: nowrap;
    }
    #cached-section .cached-mask-size-input {
      width: 50px;
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      text-align: center;
    }
    #cached-section .cached-output-container h2 {
      margin-top: 5px;
      /* margin-bottom: 10px; */
    }
    
    /* Add new styles for the sentence groups layout */
    #cached-section .cached-sentence-group {
      display: flex;
      gap: 10px;
      margin-bottom: 0px;
      flex-wrap: wrap;
    }
    
    #cached-section .cached-sentence-row {
      margin: 4px 0px; /* Reduced from 10px to 5px */
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-start;
      width: calc(50% - 10px); /* Take up roughly half minus gap space */
      min-width: 200px; /* Ensure minimum width for readability */
    }
    
    @media (max-width: 768px) {
      #cached-section .cached-sentence-row {
        width: 100%; /* Full width on small screens */
      }
    }
  </style>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>
  <script defer src="static/js/fontawesome.all.min.js"></script>
  <script src="static/js/bulma-carousel.min.js"></script>
  <script src="static/js/bulma-slider.min.js"></script>
  <script src="static/js/index.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>

    <!-- Header Section -->
    <section class="hero">
      <div class="hero-body" style="padding-bottom: 1.5rem;">
        <div class="container is-max-desktop">
          <div class="columns is-centered">
            <div class="column has-text-centered">
              <h1 class="title is-1 publication-title">UniDisc: Unified Multimodal Discrete Diffusion</h1>
              
              <div class="is-size-5 publication-authors" style="color: black;">
                <span class="author-block" style="margin-right: 10px;">
                    <a href="https://aswerdlow.com/" target="_blank" style="color: black !important;">Alexander Swerdlow<sup>*</sup></a>,
                </span>
                <span class="author-block" style="margin-right: 10px;">
                    <a href="https://mihirp1998.github.io/" target="_blank" style="color: black !important;">Mihir Prabhudesai<sup>*</sup></a>,
                </span>
                <span class="author-block" style="margin-right: 10px;">
                    <a href="https://www.lti.cs.cmu.edu/people/students/gandhi-siddharth.html" target="_blank" style="color: black !important;">Siddharth Gandhi</a>,
                </span>
                <span class="author-block" style="margin-right: 10px;">
                    <a href="https://www.cs.cmu.edu/~dpathak/" target="_blank" style="color: black !important;">Deepak Pathak</a>,
                </span>
                <span class="author-block" style="margin-right: 10px;">
                    <a href="https://www.cs.cmu.edu/~katef/" target="_blank" style="color: black !important;">Katerina Fragkiadaki</a>
                </span>
                <span class="eql-cntrb"><small><br><sup>*</sup>Equal Contribution</small></span>
                </div> 
  
                    <div class="column has-text-centered">
                      <div class="publication-links">
                        <span class="link-block">
                          <a href="https://arxiv.org/pdf/your_paper_id" target="_blank"
                          class="external-link button is-normal is-rounded is-dark">
                          <span class="icon">
                            <i class="fas fa-file-pdf"></i>
                          </span>
                          <span>Paper</span>
                        </a>
                      </span>
  
                      <!-- <span class="link-block">
                        <a href="static/pdfs/supplementary_material.pdf" target="_blank"
                        class="external-link button is-normal is-rounded is-dark">
                        <span class="icon">
                          <i class="fas fa-file-pdf"></i>
                        </span>
                        <span>Supplementary</span>
                      </a>
                    </span> -->
  
                    <span class="link-block">
                      <a href="https://github.com/alexanderswerdlow/unidisc" target="_blank"
                      class="external-link button is-normal is-rounded is-dark">
                      <span class="icon">
                        <i class="fab fa-github"></i>
                      </span>
                      <span>Code</span>
                    </a>
                  </span>
  
                 <span class="link-block">
                    <a href="https://arxiv.org/abs/your_paper_id" target="_blank"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="ai ai-arxiv"></i>
                    </span>
                    <span>arXiv</span>
                  </a>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="flipping-images-section">
      <style>
        #flipping-images-section {
          font-family: sans-serif;
          margin: 2rem auto;            /* Center the section vertically */
          max-width: 100%;              /* Make it full screen width */
          padding: 0 0px;              /* Add left/right padding */
          overflow: hidden;
        }
        #flipping-images-section .flip-card-container {
          display: flex;
          flex-wrap: wrap;
          gap: 0;
          justify-content: center;
          padding: 0;
          margin: 0;
          width: 100%;
          line-height: 0; /* Eliminate whitespace between inline elements */
          font-size: 0;
        }
        #flipping-images-section .flip-card {
          background-color: transparent;
          width: 20%; /* 5 cards per row */
          aspect-ratio: 520/720; /* Match image dimensions */
          perspective: 1000px;
          cursor: pointer;
          flex: 0 0 20%;
          position: relative;
          margin: 0;
          padding: 0;
          font-size: 16px;
          vertical-align: top;
        }
        #flipping-images-section .flip-card-inner {
          position: relative;
          width: 100%;
          height: 100%;
          transition: transform 0.6s;
          transform-style: preserve-3d;
          margin: 0;
        }
        #flipping-images-section .flip-card.flipped .flip-card-inner {
          transform: rotateY(180deg);
        }
        #flipping-images-section .flip-card-front,
        #flipping-images-section .flip-card-back {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          overflow: hidden;
          margin: 0;
          padding: 0;
        }
        #flipping-images-section .flip-card-front {
          z-index: 2;
        }
        #flipping-images-section .flip-card-back {
          transform: rotateY(180deg);
          z-index: 1;
          position: relative;
        }
        #flipping-images-section .input-label {
          position: absolute;
          top: 10px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 10px 8px;
          border-radius: 4px;
          font-size: 12px;
          opacity: 0.8;
          z-index: 3;
        }
        #flipping-images-section figure {
          margin: 0;
          padding: 0;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          line-height: 0;
          position: relative;
        }
        #flipping-images-section img {
          width: 100%;
          height: 100%;
          object-fit: contain; /* Changed from cover to contain */
          display: block;
          margin: 0;
          padding: 0;
          border: 0;
        }
        #flipping-images-section figcaption {
          display: block;
          padding: 8px;
          font-size: 14px;
          color: #333;
          text-align: center;
          background: #f5f5f5;
          margin: 0;
          line-height: normal;
        }
        
        /* New styles for transparent grey overlay on the *back* images */
        #flipping-images-section .back-image-container {
          position: relative;
          height: 100%;
        }
        #flipping-images-section .back-image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(128, 128, 128, 0.7); /* semi-transparent grey */
          pointer-events: none;
          z-index: 1;
        }
        /* Ensure the image sits below the overlay */
        #flipping-images-section .flip-card-back figure img {
          position: relative;
          z-index: 0;
        }
        /* Keep the caption above the overlay */
        #flipping-images-section .flip-card-back figure figcaption {
          position: relative;
          z-index: 2;
        }
      </style>
      <div class="flip-card-container"></div>
      <script>
        (function() {
          const flipCardsData = [
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.002.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.001.jpeg", 
              backCaption: ""
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.004.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.003.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.006.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.005.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.008.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.007.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.010.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.009.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.012.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.011.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.014.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.013.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.016.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.015.jpeg", 
              backCaption: "",
            },
            {
              frontUrl: "static/images/unidisc_main/unidisc_main.018.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.017.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl:  "static/images/unidisc_main/unidisc_main.020.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.019.jpeg",
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.022.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.021.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.024.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.023.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.026.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.025.jpeg", 
              backCaption: ""
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.028.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.027.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.030.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.029.jpeg", 
              backCaption: "",
            }
            // ,
            // { 
            //   frontUrl: "static/images/flipping/joint/19_f.png", 
            //   frontCaption: "", 
            //   backUrl: "static/images/flipping/joint/19_b.png", 
            //   backCaption: "",
            // }            
          ];

          // Randomize the order of flipCardsData
          flipCardsData.sort(() => Math.random() - 0.5);
          const container = document.querySelector('#flipping-images-section .flip-card-container');
          
          flipCardsData.forEach(card => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'flip-card';
            cardDiv.innerHTML = `
              <div class="flip-card-inner">
                <div class="flip-card-front">
                  
                  <figure>
                    <img src="${card.frontUrl}" alt="Front Image">
                    ${card.frontCaption ? `<figcaption>${card.frontCaption}</figcaption>` : ''}
                  </figure>
                </div>
                <div class="flip-card-back">
                  <span class="input-label">Input</span>
                  <figure>
                    <div class="back-image-container">
                      <img src="${card.backUrl}" alt="Back Image">
                      <div class="back-image-overlay"></div>
                    </div>
                    ${card.backCaption ? `<figcaption>${card.backCaption}</figcaption>` : ''}
                  </figure>
                </div>
              </div>
            `;
            container.appendChild(cardDiv);
          });
          
          function initFlipCards() {
            const flipCards = document.querySelectorAll('#flipping-images-section .flip-card');
            flipCards.forEach(card => {
              card.addEventListener('click', () => {
                card.classList.toggle('flipped');
              });
            });
          }
          
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initFlipCards);
          } else {
            initFlipCards();
          }
          
          // Automatic random flipping logic
          (function autoFlip() {
            const flipCards = Array.from(document.querySelectorAll('#flipping-images-section .flip-card'));
            function randomFlipCard() {
              if (flipCards.length === 0) return;
              const randomIndex = Math.floor(Math.random() * flipCards.length);
              const card = flipCards[randomIndex];
              card.classList.toggle('flipped');
              setTimeout(randomFlipCard, 3000);
            }
            setTimeout(randomFlipCard, 3000);
          })();
        })();
      </script>
    </section>

  <!-- Teaser Image -->
  <!-- <section class="hero teaser">
    <div class="container is-max-desktop">
      <div class="hero-body">
        <picture>
          <source srcset="static/images/main_fidelity.webp" type="image/webp">
          <img src="static/images/main_fidelity.webp" alt="Joint Inpainting">
        </picture>
        <h2 class="subtitle has-text-centered">
        <div style="margin-top: 10px;">
          UniDisc jointly inpainting unseen image-text pairs. This ability is not possible with prior models such as T2I diffusion or AR models.
        </div>
        </h2>
      </div>
    </div>
  </section> -->

  <!-- Abstract -->
  <section class="section hero is-light">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-centered">
        <div class="column is-four-fifths">
          <h2 id="abstract" class="title is-3">Abstract
            <a href="#abstract" class="anchor-link">
              <i class="fas fa-link"></i>
            </a>
          </h2>
          <div class="content has-text-justified">
            <p>
              Multimodal generative models that can understand and generate across multiple modalities are dominated by autoregressive (AR) approaches, which process tokens sequentially from left to right, or top to bottom. These models jointly handle images, text, video, and audio for various tasks such as image captioning, question answering, and image generation. While AR models have been highly successful in the text domain, they have been found suboptimal for processing images, videos, and audio due to the high correlation between adjacent tokens which waste inference-time compute by separately predicting each one. In this work, we explore discrete diffusion models as a unified generative formulation in the joint text and image domain, building upon their recent success in the text domain alone. Discrete diffusion models offer several advantages over AR models, including improved control over quality versus diversity of generated samples, the ability to perform joint multimodal inpainting (across both text and image domains), and greater controllability in generation through guidance. Leveraging these benefits, we present the first <strong>Uni</strong>fied Multimodal <strong>Disc</strong>rete Diffusion (UniDisc) model, which is capable of jointly processing text and images for a variety of downstream tasks. We compare UniDisc to multimodal AR models of similar capacity, demonstrating that UniDisc outperforms them in terms of both performance and inference-time compute, enhanced controllability, editability, inpainting, and flexible trade-off of inference time versus generation quality.
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>
<!-- 
  <section class="hero is-small">
    <div class="hero-body">
      <div class="container">
        <div id="results-carousel" class="carousel results-carousel">
        <div class="item">
          <img src="static/images/architecture_diagram.webp" alt="MY ALT TEXT" style="padding-bottom: 20px;"/>
          <h2 class="subtitle has-text-centered">
            UniDisc's architecture.
          </h2>
        </div>
        <div class="item">
          <img src="static/images/modality_plot.webp" alt="MY ALT TEXT"/>
          <h2 class="subtitle has-text-centered">
            UniDisc's modality plot.
          </h2>
        </div>
        <div class="item">
          <img src="static/images/carousel3.jpg" alt="MY ALT TEXT"/>
          <h2 class="subtitle has-text-centered">
          Third image description.
        </h2>
      </div>
      <div class="item">
        <img src="static/images/carousel4.jpg" alt="MY ALT TEXT"/>
        <h2 class="subtitle has-text-centered">
          Fourth image description.
        </h2>
      </div>
    </div>
  </div>
  </div>
  </section> -->

  <!-- TODO: Remove. -->
  <!-- <div id="dev-url-selector" style="text-align: center; margin-bottom: 10px; padding: 10px; background-color: #f8f8f8; border-radius: 4px;">
    <span style="font-size: 12px; color: #666;">SERVER: </span>
    <button id="prod-server-btn" class="button is-small is-primary">Older</button>
    <button id="dev-server-btn" class="button is-small">Newer</button>
  </div> -->

  <!-- cached-section starts here -->
  <section id="cached-section" class="section">
    <!-- HTML content for cached section with updated layout -->
    <div class="cached-main-container">
      <!-- Left side - Input -->
      <div class="cached-side cached-input-side">
        <div class="cached-side-title">Input</div>
        <div class="cached-grid-container">
          <img src="static/images/giraffe.png" alt="Input Image" class="cached-image" id="cached-input-image">
          <div id="cached-grid" class="cached-grid"></div>
          <div id="cached-grey-overlay" class="cached-grey-overlay"></div>
        </div>
        
        <div class="cached-sentence-builder">
          <div class="cached-reset-buttons">
            <button id="cached-reset-image" class="cached-reset-button">Restore Image</button>
            <button id="cached-clear-mask" class="cached-reset-button">Clear Mask</button>
            <button id="cached-remove-image" class="cached-reset-button">Fully Mask</button>
            <div class="cached-mask-size-container">
              <label for="cached-mask-size" class="cached-mask-size-label">Mask Size:</label>
              <input type="number" id="cached-mask-size" class="cached-mask-size-input" min="2" max="8" value="7">
            </div>
          </div>
          
          <h2 style="margin-bottom: 5px;">Build your sentence:</h2>
          <div class="cached-sentence-group">
            <div class="cached-sentence-row">
              <span class="cached-word-option" data-row="0" data-word="a tall">a tall</span>
              <span class="cached-word-option" data-row="0" data-word="a happy">a happy</span>
              <span class="cached-word-option" data-row="0" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
            </div>
            <div class="cached-sentence-row">
              <span class="cached-word-option" data-row="1" data-word="giraffe">giraffe</span>
              <span class="cached-word-option" data-row="1" data-word="puppy">puppy</span>
              <span class="cached-word-option" data-row="1" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
            </div>
          </div>
          <div class="cached-sentence-group">
            <div class="cached-sentence-row">
              <span class="cached-word-option" data-row="2" data-word="wearing a">wearing a</span>
              <span class="cached-word-option" data-row="2" data-word="with a">with a</span>
              <span class="cached-word-option" data-row="2" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
            </div>
            <div class="cached-sentence-row">
              <span class="cached-word-option" data-row="3" data-word="green shirt">green shirt</span>
              <span class="cached-word-option" data-row="3" data-word="top hat">top hat</span>
              <span class="cached-word-option" data-row="3" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
            </div>
          </div>
          <div class="cached-sentence-group">
            <div class="cached-sentence-row">
              <span class="cached-word-option" data-row="4" data-word="detailed portrait">detailed</span>
              <span class="cached-word-option" data-row="4" data-word="cartoon style">cartoon</span>
              <span class="cached-word-option" data-row="4" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
            </div>
          </div>
          <div id="cached-current-sentence" class="cached-text-display">Click word pairs above to build your sentence!</div>

        </div>
      </div>
      
      <!-- Right side - Output -->
      <div class="cached-side cached-output-side">
        <div class="cached-side-title">Output</div>
        <div class="cached-grid-container">
          <img src="static/images/giraffe.png" alt="Output Image" class="cached-image" id="cached-output-image">
          <div id="cached-output-overlay" class="cached-grey-overlay" style="display: block;"></div>
        </div>
        
        <div class="cached-output-container">
          <h2>Model Response:</h2>
          <div id="cached-response-text" class="cached-output-display">Select words and interact with the input image to see results here.</div>
        </div>
      </div>
    </div>

    <script>
      (() => {

        let API_URL = "https://rerun.aswerdlow.com/v1/chat/completions"; // Production URL
        // const DEV_API_URL = "https://grafana.aswerdlow.com/v1/chat/completions"; // Dev URL
        
        // // Add URL selector functionality
        // const devUrlSelector = document.getElementById('dev-url-selector');
        // const prodServerBtn = document.getElementById('prod-server-btn');
        // const devServerBtn = document.getElementById('dev-server-btn');
        
        // // Only initialize if the elements exist (for easy disabling)
        // if (devUrlSelector && prodServerBtn && devServerBtn) {
        //   prodServerBtn.addEventListener('click', () => {
        //     API_URL = API_URL;
        //     prodServerBtn.classList.add('is-primary');
        //     devServerBtn.classList.remove('is-primary');
        //     console.log("Using production server:", API_URL);
        //   });
          
        //   devServerBtn.addEventListener('click', () => {
        //     API_URL = DEV_API_URL;
        //     devServerBtn.classList.add('is-primary');
        //     prodServerBtn.classList.remove('is-primary');
        //     console.log("Using development server:", API_URL);
        //   });
        // }

        const HARDCODED_CONFIG = {
            temperature: 0.9,
            top_p: 0.95,
            maskgit_r_temp: 4.5,
            cfg: 2.5,
            max_tokens: 32,
            resolution: 512,
            sampling_steps: 32,
            sampler: "maskgit_nucleus",
            use_reward_models: false
        };

        const GRID_SIZE = 8; // GRID_SIZE x GRID_SIZE.
        // Replace the hardcoded MASK_SIZE with a function
        function getMaskSize() {
          const maskSizeInput = document.getElementById('cached-mask-size');
          if (maskSizeInput) {
            const size = parseInt(maskSizeInput.value, 10);
            // Validate the size is between 2 and GRID_SIZE
            return Math.min(Math.max(size, 2), GRID_SIZE);
          }
          return 6; // Default value if input not found
        }
        
        // --- Utility functions ---
        async function processImage(imageBytes) {
            const img = await createImageBitmap(new Blob([imageBytes], { type: 'image/jpeg' }));
            const canvas = squareCrop(img);
            return canvas.convertToBlob({ quality: 0.95, type: 'image/jpeg' });
        }
        
        function squareCrop(img) {
            const size = Math.min(img.width, img.height);
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img,
                (img.width - size) / 2, (img.height - size) / 2, size, size,
                0, 0, size, size
            );
            return canvas;
        }
        
        function encodeMask(maskArray) {
            const rows = maskArray.length;
            const cols = maskArray[0].length;
            const canvas = document.createElement('canvas');
            canvas.width = cols;
            canvas.height = rows;
            const ctx = canvas.getContext('2d');
        
            const imageData = ctx.createImageData(cols, rows);
            for (let i = 0; i < maskArray.flat().length; i++) {
                const val = maskArray.flat()[i];
                const color = val ? 255 : 0;
                const pixelIndex = i * 4; // Each pixel uses 4 bytes in the array
                
                imageData.data[pixelIndex]     = color; // R
                imageData.data[pixelIndex + 1] = color; // G
                imageData.data[pixelIndex + 2] = color; // B
                imageData.data[pixelIndex + 3] = color; // A
            }
            ctx.putImageData(imageData, 0, 0);
        
            const dataURL = canvas.toDataURL("image/png");
            return {
                data: dataURL.split(',')[1],
                width: cols,
                height: rows
            };
        }
        
        let isImageRemoved = false; // Add flag to track if image is removed
        let DISABLE_HASH_CHECKING = false; // Add this flag to globally disable hash checking
        
        // Refactored callUnidiscAPI function accepting an options parameter.
        // This function will be used both by normal interactions and by the precaching code.
        async function callUnidiscAPI(imageBlob, maskArray, sentence, options = {}) {
            // Use effective image removal flag based on options or the global isImageRemoved.
            const effectiveIsImageRemoved = (options.noImage === true) ? true : isImageRemoved;
            let customAPIUrl = API_URL;

            // Replace <mask> with <m> for API call
            const apiSentence = sentence.replace(/<mask>/g, "<m>");
            console.log("Called API with sentence: ", apiSentence);
            const messages = [{
                    role: "user",
                    content: [
                        { type: "text", text: apiSentence }
                    ]
                },
                {
                    role: "assistant",
                    content: []
                }
            ];

            // Check if we need to include the image and mask
            const hasMaskedText = apiSentence.includes("<m>");
            const hasMaskedImage = maskArray && maskArray.some(row => row.some(cell => cell === true));

            let imageBase64;
            let maskData;

            // Only include image and mask if needed AND image is not removed.
            if ((hasMaskedText || hasMaskedImage) && !effectiveIsImageRemoved) {
                const resizedImage = await processImage(await imageBlob.arrayBuffer());
                imageBase64 = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(resizedImage);
                });
                messages[1].content.push({
                    type: "image_url",
                    image_url: { url: imageBase64 },
                    is_mask: false
                });

                if (maskArray) {
                    maskData = encodeMask(maskArray);
                    messages[1].content.push({
                        type: "image_url",
                        image_url: {
                            url: `data:image/png;base64,${maskData.data}`,
                            mask_info: JSON.stringify({
                                width: maskData.width,
                                height: maskData.height
                            })
                        },
                        is_mask: true
                    });
                }
            }

            if (messages.length > 0 &&
                messages[messages.length - 1].role === 'assistant' &&
                (!messages[messages.length - 1].content ||
                 messages[messages.length - 1].content.length === 0)) {
                console.log("Removing empty assistant message");
                messages.pop(); // Remove the empty assistant message
            }

            // Create the payload without the hash first.
            const payload = {
                messages,
                model: "unidisc",
                ...HARDCODED_CONFIG
            };

            // Caching logic - hash the entire request payload.
            let hash = null;
            
            // Skip hash generation and checking if DISABLE_HASH_CHECKING is true
            if (!DISABLE_HASH_CHECKING && !options.skipHashChecking) {
                try {
                    const payloadString = JSON.stringify(payload);
                    const encoder = new TextEncoder();
                    const data = encoder.encode(payloadString);

                    if (typeof crypto !== 'undefined' && crypto.subtle) {
                        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                        console.log("Hash generated from full payload:", hash);
                    } else {
                        throw new Error('Web Crypto API is not available. Please ensure you are serving your page over HTTPS or via localhost.');
                    }
                } catch (error) {
                    console.error('Error generating hash:', error);
                }
            }

            try {
                // Check cache using the hash only if hash checking is enabled
                if (hash && !DISABLE_HASH_CHECKING && !options.skipHashChecking) {
                    try {
                        const response = await fetch(`/static/responses/${hash}.json`, {
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json'
                            }
                        });
                        if (response.ok) {
                            const jsonContent = await response.text();
                            console.log("Cache hit!");
                            const cachedData = JSON.parse(jsonContent);
                            console.log("Cached data: ", cachedData);
                            return {
                                choices: [{
                                    index: 0,
                                    message: cachedData,
                                    finish_reason: "stop"
                                }]
                            };
                        } else {
                            console.log("Cache miss:", response);
                        }
                    } catch (cacheError) {
                        console.log("Cache access failed:", cacheError);
                        console.log("Proceeding with direct API call");
                    }
                }
            } catch (error) {
                console.log("Cache miss:", error)
            }

            console.log("Hash: ", hash);

            // Only add hash to payload if hash checking is enabled
            if (hash && !DISABLE_HASH_CHECKING) {
                payload.request_hash = hash;
            }

            console.log("Payload: ", payload);

            try {
                const response = await fetch(customAPIUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'POST, OPTIONS',
                        'Access-Control-Allow-Headers': 'Content-Type'
                    },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const data = await response.json();
                console.log("Response: ", data);
                return data;
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        window.callUnidiscAPI = callUnidiscAPI;
        
        // --- Begin cached section-specific code ---
        const section = document.getElementById('cached-section');
        const grid = section.querySelector('#cached-grid');
        const currentSentence = section.querySelector('#cached-current-sentence');
        const responseText = section.querySelector('#cached-response-text');
        const inputImage = section.querySelector('#cached-input-image');
        const outputImage = section.querySelector('#cached-output-image');
        const cells = [];
        let currentRow = 0;
        let currentCol = 0;
        let maskLocked = false; // Add this flag to track if mask is locked in place
        let activeMask = null; // Track the currently active mask coordinates
        
        // Create grid cells based on GRID_SIZE.
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
          const cell = document.createElement('div');
          cell.className = 'cached-grid-cell';
          cell.dataset.row = Math.floor(i / GRID_SIZE);
          cell.dataset.col = i % GRID_SIZE;
          grid.appendChild(cell);
          cells.push(cell);
        }
        
        // Update createMaskArray to use the dynamic mask size
        function createMaskArray(topLeftRow, topLeftCol) {
          const maskSize = getMaskSize();
          const maskArray = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(false));
          for (let r = topLeftRow; r < topLeftRow + maskSize && r < GRID_SIZE; r++) {
            for (let c = topLeftCol; c < topLeftCol + maskSize && c < GRID_SIZE; c++) {
              maskArray[r][c] = true;
            }
          }
          return maskArray;
        }
        
        // Update highlightCells to use the dynamic mask size
        function highlightCells(row, col) {
          // If mask is locked, don't update highlights on mousemove
          if (maskLocked) return;
          
          cells.forEach(cell => cell.classList.remove('cached-highlighted'));
          const maskSize = getMaskSize();
          const offset = Math.floor(maskSize / 2);
          const topLeftRow = Math.min(Math.max(row - offset, 0), GRID_SIZE - maskSize);
          const topLeftCol = Math.min(Math.max(col - offset, 0), GRID_SIZE - maskSize);
          currentRow = row;
          currentCol = col;

          for (let r = topLeftRow; r < topLeftRow + maskSize && r < GRID_SIZE; r++) {
            for (let c = topLeftCol; c < topLeftCol + maskSize && c < GRID_SIZE; c++) {
              const cell = cells[r * GRID_SIZE + c];
              if (cell) {
                cell.classList.add('cached-highlighted');
              }
            }
          }
        }
        
        const selectedWords = new Array(6).fill(null);
      

        const defaultSelections = [
            "a tall",
            "puppy",
            "wearing a",
            "top hat",
            "cartoon style",
        ];

        // Initialize with default selections
        defaultSelections.forEach((word, index) => {
            selectedWords[index] = word;
            const wordElement = section.querySelector(`.cached-word-option[data-row="${index}"][data-word="${word}"]`);
            if (wordElement) {
                wordElement.classList.add('cached-selected');
            }
        });
        
        updateSentence();
        
        section.querySelectorAll('.cached-word-option').forEach(word => {
            word.addEventListener('click', async () => {
                const row = parseInt(word.dataset.row);
                const wordText = word.dataset.word;
        
                // If auto-reset mode is enabled AND the image is not already removed,
                // reset the image before changing text
                if (window.autoResetOnMaskSelect && !isImageRemoved) {
                    inputImage.src = originalImageSrc;
                    inputImage.style.filter = "none"; // Clear any filters
                    isImageRemoved = false; // Reset the image removed flag
                    
                    // Hide the grey overlay
                    const greyOverlay = section.querySelector('#cached-grey-overlay');
                    greyOverlay.style.display = "none";
                    
                    // Reset output display
                    responseText.textContent = 'Select words and interact with the input image to see results here.';
                    outputImage.src = originalImageSrc;
                }
        
                section.querySelectorAll(`.cached-word-option[data-row="${row}"]`)
                       .forEach(w => w.classList.remove('cached-selected'));
        
                word.classList.add('cached-selected');
                selectedWords[row] = wordText;
        
                updateSentence();
                
                // Call API directly without requiring a mask
                try {
                    await updateOutput();
                } catch (error) {
                    console.error('Error updating output after text change:', error);
                }
            });
        });
        
        function updateSentence() {
            // Set the expected number of characters for each mask segment.
            // The approximation is 4 characters per token (spaces included),
            // so if we expect (for example) 6 characters, that results in Math.ceil(6/4) = 2 tokens.
            const DEFAULT_MASK_EXPECTED_CHARS = 6; // adjust this value as needed
            const maskTokenCount = Math.ceil(DEFAULT_MASK_EXPECTED_CHARS / 4);

            // Get the selected (or default) words.
            const words = selectedWords.filter(word => word !== null);
            const finalWords = words.length > 0 ? words : defaultSelections;
            
            // For each token, if it is "<mask>", expand it into multiple mask tokens.
            const sentenceParts = finalWords.map(word => {
                if (word === "<mask>") {
                    // Create a string that repeats "<mask>" the appropriate number of times.
                    return new Array(maskTokenCount).fill("<mask>").join("");
                }
                return word;
            });
            
            // Join all tokens with a space and append a period.
            const sentence = sentenceParts.join(" ") + ".";
            currentSentence.textContent = sentence;
        }
        
        grid.addEventListener('mousemove', (e) => {
            const rect = grid.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor((x / rect.width) * GRID_SIZE);
            const row = Math.floor((y / rect.height) * GRID_SIZE);
            highlightCells(row, col);
        });
        
        async function updateOutput() {
            try {
                const currentSentence = section.querySelector('#cached-current-sentence');
                const responseText = section.querySelector('#cached-response-text');
                const greyOverlay = section.querySelector('#cached-grey-overlay');
                const outputOverlay = section.querySelector('#cached-output-overlay');

                let maskArray = null;
                
                // Only create a mask if we have an active mask
                if (activeMask) {
                    const [topLeftRow, topLeftCol] = activeMask;
                    maskArray = createMaskArray(topLeftRow, topLeftCol);
                }
        
                const sentence = currentSentence.textContent;
                const imageBlob = await fetch(inputImage.src).then(res => res.blob());
                
                // Show loading state
                responseText.textContent = 'Processing your request...';
                // Show grey overlay while loading
                outputOverlay.style.display = "block";
                // Reset any previous custom text in the overlay
                outputOverlay.innerHTML = "";
                
                console.log("sentence: ", sentence);
                const response = await callUnidiscAPI(imageBlob, maskArray, sentence);
                
                const message = response.choices?.[0]?.message;
                if (!message) {
                    throw new Error("No message found in the API response");
                }

                // Extract text content if available
                let textContent = '';
                if (Array.isArray(message.content)) {
                    const textPart = message.content.find(part => part.type === "text");
                    if (textPart && textPart.text) {
                        textContent = textPart.text;
                    }
                } else if (typeof message.content === 'string') {
                    textContent = message.content;
                }

                // Update response text
                if (textContent) {
                    responseText.textContent = textContent;
                } else {
                    responseText.textContent = 'Image updated successfully!';
                }

                // Check if there's an image in the response
                let imageUrl = null;
                if (Array.isArray(message.content)) {
                    const imagePart = message.content.find(part => part.type === "image_url");
                    if (imagePart && imagePart.image_url && imagePart.image_url.url) {
                        imageUrl = imagePart.image_url.url;
                    }
                } else if (message.image_url && message.image_url.url) {
                    imageUrl = message.image_url.url;
                }

                // Update the output image if we have an image response
                if (imageUrl) {
                    const newImageUrl = imageUrl.startsWith("data:image/jpeg;base64,")
                        ? imageUrl
                        : `data:image/jpeg;base64,${imageUrl}`;
                    outputImage.src = newImageUrl;
                    // Hide the output overlay when image is ready
                    outputOverlay.style.display = "none";
                } else {
                    // No image in response, but API was successful
                    // Show "Image Fixed" text on the overlay
                    outputOverlay.style.display = "block";
                    outputOverlay.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100%; color: white; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 3px black;">Image Fixed</div>';
                }
            } catch (error) {
                console.error('Output update failed:', error);
                responseText.textContent = 'Error: ' + error.message;
                // Keep the grey overlay visible on error
            }
        }
        
        window.autoResetOnMaskSelect = true;
        grid.addEventListener('click', async () => {
            const maskSize = getMaskSize();
            const offset = Math.floor(maskSize / 2);
            // Compute the top-left coordinate of the mask ensuring it stays within grid bounds.
            const safeTopLeftRow = Math.min(Math.max(currentRow - offset, 0), GRID_SIZE - maskSize);
            const safeTopLeftCol = Math.min(Math.max(currentCol - offset, 0), GRID_SIZE - maskSize);
            
            // If auto-reset mode is enabled, reset the image before selecting the mask
            if (window.autoResetOnMaskSelect) {
                inputImage.src = originalImageSrc;
                inputImage.style.filter = "none"; // Clear any filters
                isImageRemoved = false; // Reset the image removed flag
                
                // Hide the grey overlay
                const greyOverlay = section.querySelector('#cached-grey-overlay');
                greyOverlay.style.display = "none";
            }
            
            if (maskLocked && 
                activeMask && 
                activeMask[0] === safeTopLeftRow && 
                activeMask[1] === safeTopLeftCol) {
                // If clicking on the same mask area, unlock it
                console.log("Clearing mask after clicking on the same mask area");
                maskLocked = false;
                activeMask = null;
                // Clear highlights
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
                // Don't call updateOutput when just removing the mask
                return;
            } else {
                // Lock the mask at current position
                maskLocked = true;
                activeMask = [safeTopLeftRow, safeTopLeftCol];
                
                // Ensure the mask area is properly highlighted
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
                for (let r = safeTopLeftRow; r < safeTopLeftRow + maskSize && r < GRID_SIZE; r++) {
                    for (let c = safeTopLeftCol; c < safeTopLeftCol + maskSize && c < GRID_SIZE; c++) {
                        const cell = cells[r * GRID_SIZE + c];
                        if (cell) {
                            cell.classList.add('cached-highlighted');
                        }
                    }
                }
            }
        
            try {
                await updateOutput();
            } catch (error) {
                console.error('Error updating output:', error);
            }
        });
        
        grid.addEventListener('mouseleave', () => {
            // Only clear highlights if mask is not locked
            if (!maskLocked) {
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
            }
        });
        
        // Initialize highlighting with default values.
        highlightCells(1, 1);

        // Add event listeners for the reset buttons
        const resetImageButton = section.querySelector('#cached-reset-image');
        const clearMaskButton = section.querySelector('#cached-clear-mask');
        const removeImageButton = section.querySelector('#cached-remove-image');
        const greyOverlay = section.querySelector('#cached-grey-overlay');
        const originalImageSrc = "static/images/giraffe.png"; // Store the original image source
        
        // Reset image button functionality
        resetImageButton.addEventListener('click', () => {
          inputImage.src = originalImageSrc;
          inputImage.style.filter = "none"; // Clear any filters
          isImageRemoved = false; // Reset the image removed flag
          
          // Hide the grey overlay
          greyOverlay.style.display = "none";
          
          // Also clear the mask when resetting the image
          console.log("Clearing mask after resetting the image");
          maskLocked = false;
          activeMask = null;
          cells.forEach(cell => cell.classList.remove('cached-highlighted'));
          
          // Reset the output image and response text
          outputImage.src = originalImageSrc;
          responseText.textContent = 'Select words and interact with the input image to see results here.';
          // Show the output overlay when resetting
          document.querySelector('#cached-output-overlay').style.display = "block";
        });
        
        // Clear mask button functionality
        clearMaskButton.addEventListener('click', () => {
          console.log("Clearing mask without affecting the image");
          maskLocked = false;
          activeMask = null;
          cells.forEach(cell => cell.classList.remove('cached-highlighted'));
          
          // Update the output to reflect that the mask has been cleared
          responseText.textContent = 'Mask cleared. Select an area of the image to mask or choose different words.';
        });
        
        // Remove image button functionality
        removeImageButton.addEventListener('click', async () => {
          // Show the solid grey overlay
          greyOverlay.style.display = "block";
          isImageRemoved = true; // Set flag to indicate image is removed
          
          // Clear any active mask
          console.log("Clearing mask after removing image");
          maskLocked = false;
          activeMask = null;
          cells.forEach(cell => cell.classList.remove('cached-highlighted'));
          
          // Call the API after fully masking the image
          try {
            await updateOutput();
          } catch (error) {
            console.error('Error updating output after fully masking image:', error);
          }
        });

        // Add event listener for mask size changes to update the highlight
        const maskSizeInput = document.getElementById('cached-mask-size');
        if (maskSizeInput) {
          maskSizeInput.addEventListener('change', () => {
            // If we have an active mask, clear it as the size has changed
            if (maskLocked && activeMask) {
              maskLocked = false;
              activeMask = null;
              cells.forEach(cell => cell.classList.remove('cached-highlighted'));
            }
            // Update the highlight with the current mouse position
            if (currentRow !== undefined && currentCol !== undefined) {
              highlightCells(currentRow, currentCol);
            }
          });
        }

        window.enablePrecaching = false;
        if (window.enablePrecaching) {
          setTimeout(() => {
            async function precache() {
              async function getImageBlob() {
                const img = document.querySelector('.cached-image');
                if (!img) throw new Error("No image element found for precaching.");
                return await fetch(img.src).then(res => res.blob());
              }

              const rowOptions = {};
              const wordElements = document.querySelectorAll('#cached-section .cached-word-option');
              wordElements.forEach(elem => {
                const row = elem.getAttribute('data-row');
                const word = elem.getAttribute('data-word');
                if (!rowOptions[row]) rowOptions[row] = [];
                rowOptions[row].push(word);
              });

              const textCombinations = [];

              // Generate all possible combinations of words from all rows (0-5)
              if (Object.keys(rowOptions).length > 0) {
                function buildSentences(currentSentence, currentRow) {
                  if (currentRow > 4) {
                    console.log(currentSentence + ".");
                    textCombinations.push(currentSentence + ".");
                    return;
                  }
                  
                  if (rowOptions[currentRow]) {
                    for (const word of rowOptions[currentRow]) {
                      let newSentence;
                      if (currentSentence === "") {
                        newSentence = word;
                      } else {
                        const joiner = (currentSentence.endsWith("<mask>") || word === "<mask>") ? "<mask>" : " ";
                        newSentence = currentSentence + joiner + word;
                      }
                      buildSentences(newSentence, currentRow + 1);
                    }
                  } else {
                    buildSentences(currentSentence, currentRow + 1);
                  }
                }
                
                buildSentences("", 0);
              }
              
              const maskPositions = [];
              for (let r = 0; r <= GRID_SIZE - getMaskSize(); r++) {
                for (let c = 0; c <= GRID_SIZE - getMaskSize(); c++) {
                  maskPositions.push([r, c]);
                }
              }

              let imageBlob = null;
              try {
                imageBlob = await getImageBlob();
              } catch (e) {
                console.error("Failed to fetch image for precaching:", e);
              }

              const apiCallConfigs = [];
              for (const text of textCombinations) {
                // (1) With image and every possible mask.
                for (const [topRow, topCol] of maskPositions) {
                  const maskArray = createMaskArray(topRow, topCol);
                  apiCallConfigs.push({ 
                    text, 
                    maskArray, 
                    type: "with mask",
                    position: [topRow, topCol]
                  });
                }
                // (2) With image and no mask.
                apiCallConfigs.push({ 
                  text, 
                  maskArray: null, 
                  type: "no mask" 
                });
                // (3) No image (simulate removal).
                apiCallConfigs.push({ 
                  text, 
                  maskArray: null, 
                  type: "no image",
                  noImage: true 
                });
              }

              const BATCH_SIZE = 1024;      // Process this many requests at once
              const DELAY_MS = 1000;      // Wait this many ms between batches
              let completedCalls = 0;

              for (let i = 0; i < apiCallConfigs.length; i += BATCH_SIZE) {
                const batch = apiCallConfigs.slice(i, i + BATCH_SIZE);
                
                await Promise.all(
                  batch.map(config => {
                    return callUnidiscAPI(
                      imageBlob, 
                      config.maskArray, 
                      config.text, 
                      { 
                        noImage: config.noImage
                      }
                    )
                    .then(() => {
                      completedCalls++;
                      if (completedCalls % 10 === 0) {
                        console.log(`Precaching progress: ${completedCalls}/${apiCallConfigs.length} complete`);
                      }
                    })
                    .catch(err => console.error(
                      "Precaching call failed:", 
                      config.type, 
                      config.text, 
                      config.position || "", 
                      err
                    ));
                  })
                );
                
                // Add delay between batches (skip delay for the last batch)
                if (i + BATCH_SIZE < apiCallConfigs.length) {
                  await new Promise(resolve => setTimeout(resolve, DELAY_MS));
                }
              }

              console.log(`Precaching complete. Total API calls made: ${apiCallConfigs.length}`);
            }
            precache();
          }, 1000);
        }
      })();
    </script>
  </section>

  <section class="hero is-small pt-6 pb-3">
    <div class="hero-body">
      <div class="container">
        <h2 id="overall_architecture" class="title is-3 has-text-centered">
          UniDisc Overview
          <a href="#overall_architecture" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="padding-top: 20px;">
          <div class="column is-five-sixths has-text-centered">
            <picture>
              <source srcset="static/images/method_figure.png" type="image/png">
              <img src="static/images/method_figure.png" alt="Modality Plot">
            </picture>
            <p style="padding-bottom: 30px;">UniDisc is a unified multimodal discrete diffusion model that can jointly process and generate text and images. First, each modality is converted into a sequnece of discrete tokens and we randomly replace a subset of these tokens with the [MASK] token according to a noise schedule and denoted in the figure with grey boxes. We jointly denoise the image and text and supervise with a weighted cross-entropy loss. At inference time we begin with a set of [MASK] tokens and iteratively unmask tokens.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="hero is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="scaling_laws" class="title is-3 has-text-centered">
         UniDisc Training Scaling Laws
          <a href="#scaling_laws" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="padding-top: 1.5rem;">
          <div class="column is-five-sixths has-text-centered">
            <div class="columns">
              <div class="column">
                <picture>
                  <source srcset="static/images/scaling.png" type="image/png">
                  <img src="static/images/scaling.png" alt="Scaling Laws">
                </picture>
              </div>
              <div class="column">
                <picture>
                  <source srcset="static/images/scaling_nar_ar.png" type="image/png">
                  <img src="static/images/scaling_nar_ar.png" alt="NAR vs AR Scaling">
                </picture>
              </div>
            </div>
            <p>Scaling Analysis for AR and UniDisc models: (Left) IsoFLOP curves for UniDisc, plotting varying model size for a fixed FLOP budget. (Right) Estimating optimal parameter size for each budget - minima of fitted parabola, we plot scaling laws for both AR and UniDisc. We find 13.2x more compute is required for UniDisc to achieve the same overall loss as AR.</p>
          </div>
        </div>

      </div>
    </div>
  </section>

  <section class="hero is-small  pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="cfg_ablation" class="title is-3 has-text-centered">
          UniDisc vs. Autoregressive at Inference
          <a href="#cfg_ablation" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="padding-top: 1.5rem;">
          <div class="column is-five-sixths has-text-centered">
            <video width="100%" autoplay loop muted playsinline>
              <source src="static/videos/uni_v_ar.mov" type="video/mp4">
              Your browser does not support the video tag.
            </video>
          </div>
          
        </div>
        <p class="has-text-centered"> UniDisc can generate images with a lot lesser forward passes than AR models.</p>
        <div class="columns is-centered" style="margin-top: 2rem;">
          <div class="column is-five-sixths has-text-centered">
            <div style="display: flex; justify-content: center; gap: 1px;">
              <picture>
                <source srcset="static/images/cfg_fid.webp" type="image/webp">
                <img src="static/images/cfg_fid.webp" alt="Concept Generation" style="width: 95%;">
              </picture>
              <picture>
                <source srcset="static/images/cfg_clip_score.webp" type="image/webp">
                <img src="static/images/cfg_clip_score.webp" alt="Concept Generation" style="width: 95%;"> 
              </picture>
            </div>
            <p>Conditional generation results for both FID and CLIP metrics, across a range of CFG values.} We find that AR is more sensitive to the CFG weighting, with a narrower optimal range. We find UniDisc achieves better FiD and CLIP score than Unifiied Autoregressive models such as Chameleon.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="hero is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="zero_shot_editing" class="title is-3 has-text-centered">
          Zero-shot Multimodal Editing with UniDisc
          <a href="#zero_shot_editing" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="padding-top: 1.5rem;">
          <div class="column is-five-sixths has-text-centered">
            <video width="100%" autoplay loop muted playsinline>
              <source src="static/videos/unidisc_edit.mov" type="video/mp4">
              Your browser does not support the video tag.
            </video>
            <p></p>
          </div>
        </div>
        <div class="columns is-centered" style="padding-top: 3.5rem;">
          <div class="column is-five-sixths has-text-centered">
            <h3 class="subtitle">Zero-shot Multimodal Editing Results</h3>
            <picture>
              <source srcset="static/images/automatic_editing_crop.png" type="image/png">
              <img src="static/images/automatic_editing_crop.png" alt="Image Inpainting">
            </picture>
            <p>UniDisc can automatically improve a user provided image and caption. We adopt a best-of-n sampling strategy with n distinct noise masks. We unroll each generation until completion and use the model's own likelihood to determine select the best generation.</p>
            <br>
            <p>We augment real images by overlaying random objects from the COCO dataset. Similarly, we augment captions by asking an LLM to generate purposely incorrect variations. We then randomly mask the image and text inputs and unmask as described above, automatically removing these undesired image artifacts and generating the correct caption. There is no human intervention or masking in any examples. In the final row, we fix the text prompt, and only allow updates to the image.</p>
          </div>
        </div>
      </div>
    </div>
  </section>


  <!-- <section class="hero is-small is-light pt-4 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="multimodal_caching" class="title is-3 has-text-centered">
          Multimodal Caching
          <a href="#multimodal_caching" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>

        <div class="columns is-centered">
          <div class="column is-three-fifths has-text-centered">
            <picture>
              <source srcset="static/images/modality_plot.webp" type="image/webp">
              <img src="static/images/modality_plot.webp" alt="Modality Plot">
            </picture>
            <p style="padding-bottom: 30px;">To take advantage of this, we design a novel multimodal caching mechanism that allows UniDisc to reuse the same denoising steps for specific modalities, reducing overall inference time.</p>
            <picture>
              <source srcset="static/images/architecture_diagram.webp" type="image/webp">
              <img src="static/images/architecture_diagram.webp" alt="Text Generation from Image">
            </picture>
            <p>We maintain different noising schedules for image and text tokens, effectively setting a larger \(dt_{\text{image}}\) and a smaller \(dt_{\text{text}}\).</p>
          </div>
        </div>
        
      </div>
    </div>
  </section> -->

 
  <section class="hero  is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="generation_analysis" class="title is-3 has-text-centered">
          Generation Analysis
          <a href="#generation_analysis" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="margin-top: 2rem;">
          <div class="column is-five-sixths has-text-centered">
            <picture>
              <source srcset="static/images/denoising_viz_new.png" type="image/png">
              <img src="static/images/denoising_viz_new.png" alt="Joint Infilling">
            </picture>
            <p>Intermediate Steps during Joint Infilling of Image and Text. UniDisc jointly infills both image and text during generation.</p>
          </div>
        </div>

        <div class="columns is-centered" style="margin-top: 3rem;">
          <div class="column is-five-sixths has-text-centered">
            <h3 class="subtitle" style="margin-bottom: 2.0rem;">Uniform Concept Generation</h3>
            <picture>
              <source srcset="static/images/seg_viz_v2.webp" type="image/webp">
              <img src="static/images/seg_viz_v2.webp" alt="Concept Generation">
            </picture>
            <p>To quantitatively analyze the generation order, we use an language-grounded segmentation model (Grounded SAM 2) to segment the image given the text prompt. We then record the order of token decoding when using confidence-based sampling and plot the progression of each region. We observe that the model generates uniformly over concepts and modalities. In AR this is not possible as the model must generate in a specific order (e.g., text first, then raster-order), and thus the model cannot jointly reason over modalities and multiple parts of the image.</p>
          </div>
        </div>

      </div>
    </div>
  </section>



 

  <section class="hero is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="cfg_unidisc_ar_analysis" class="title is-3 has-text-centered">
          Classifier-Free Guidance Analysis
          <a href="#cfg_unidisc_ar_analysis" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered">
          <div class="column is-five-sixths">
            <div class="columns">
              <!-- Left column for the graph -->
              <div class="column is-half">
                <picture>
                  <source srcset="static/images/cfg_dist_vs_pct_tokens.png" type="image/png">
                  <img src="static/images/cfg_dist_vs_pct_tokens.png" alt="CFG Distance vs Percent Tokens">
                </picture>
                <p class="has-text-centered">L2 distance between unconditional and conditional logits on currently masked tokens as sampling steps increase.</p>
              </div>
              
              <!-- Right column for the table -->
              <div class="column is-half" style="margin-top: 5.5rem;">
                <table class="table is-bordered is-centered" style="margin: 0 auto;">
                  <thead>
                    <tr>
                      <th>Steps</th>
                      <th>CLIP Score</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>[1-3]</td>
                      <td>0.301</td>
                    </tr>
                    <tr>
                      <td>[12-14]</td>
                      <td>0.293</td>
                    </tr>
                    <tr>
                      <td>[22-24]</td>
                      <td>0.283</td>
                    </tr>
                    <tr>
                      <td><strong>All (24)</strong></td>
                      <td>0.312</td>
                    </tr>
                  </tbody>
                </table>
                <p class="has-text-centered">Comparing CLIP scores by applying CFG only on specific steps. This shows CFG has the most impact on the initial denoising steps (total steps = 24).</p>
              </div>
            </div>
            <p class="has-text-centered">CFG significantly impacts the performance difference between UniDisc and Autoregressive model. To analyze this, we compare UniDisc with an AR model. The left figure shows the difference between conditional and unconditional predictions at various decoding stages. We observe that (a) the difference decreases as more tokens are decoded and (b) UniDisc maintains higher logit distances than AR throughout the process.

             We believe UniDisc's flexibility to generate tokens in any order allows it to keep a higher logit distance between unconditional and conditional predictions, thus allowing it to leverage CFG more effectively. The right table supports this, showing that applying CFG in just the first 3 steps achieves similar CLIP scores to applying it throughout all steps, while later-step CFG has minimal impact, which also correlates with the conditional and unconditional distance reducing as more tokens are decoded.
              </p>
          </div>
        </div>
        <div class="columns is-centered">
          <div class="column is-five-sixths has-text-centered">
            <h3 class="subtitle">Qualitative Effect of Classifier-Free Guidance</h3>
            <picture>
              <source srcset="static/images/unidisc_cfg.png" type="image/png">
              <img src="static/images/unidisc_cfg.png" alt="Classifier-Free Guidance" style="margin-bottom: -0.6rem;">
            </picture>
            <p style="margin-bottom: -0.8rem;">Effect of classifier-free guidance in UniDisc, from left to right.</p>
            <!-- <p>Caption: <i>Crab meditating, surfboard, orange sun setting, rainbow clouds, zen beach.</i></p> -->
          </div>
        </div>
      </div>
    </div>
  </section>

    <!-- BibTeX Citation -->
  <section class="section" id="BibTeX">
    <div class="container is-max-desktop content">
      <h2 class="title">BibTeX</h2>
      <pre><code>@article{your_citation_key,
      title={UniDisc: Unified Multimodal Discrete Diffusion},
      author={First Author and Second Author and Third Author},
      journal={Conference Name},
      year={2023}
      }</code></pre>
        </div>
    </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="columns is-centered">
        <div class="column is-8">
          <div class="content">
  
            <p>
              This page was built using the <a href="https://github.com/eliahuhorwitz/Academic-project-page-template" target="_blank">Academic Project Page Template</a> which was adopted from the <a href="https://nerfies.github.io" target="_blank">Nerfies</a> project page. This website is licensed under a <a rel="license"  href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative
              Commons Attribution-ShareAlike 4.0 International License</a>.
            </p>
  
          </div>
        </div>
      </div>
    </div>
  </footer>


  <!-- Good lazy loading with animation. For some reason, adding this conflicts with <picture> which is needed to optionally load webp images so for now we add the lazy load attribute (which should be removed when using the below code.) -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Ensure that we wait for all images to be loaded before scrolling to hash
        const images = document.querySelectorAll('img');

        let imagesLoaded = 0;
        const totalImages = images.length;

        images.forEach((img) => {
          if (img.complete) {
            imagesLoaded++;
          } else {
            img.addEventListener('load', function() {
              imagesLoaded++;
              if (imagesLoaded === totalImages) {
                scrollToHash();
              }
            });
            img.addEventListener('error', function() {
              imagesLoaded++;
              if (imagesLoaded === totalImages) {
                scrollToHash();
              }
            });
          }
        });

        // If no images or all images are already loaded
        if (totalImages === 0 || imagesLoaded === totalImages) {
          scrollToHash();
        }

        function scrollToHash() {
          const hash = window.location.hash;
          if (hash) {
            // Use setTimeout to ensure scroll happens after all content is visible
            setTimeout(() => {
              const target = document.querySelector(hash);
              if (target) {
                target.scrollIntoView({ behavior: 'smooth' });
              }
            }, 100);
          }
        }
      });

    $(document).ready(function() {
      $('a.anchor-link').on('click', function(e) {
        e.preventDefault(); // Prevent the default anchor behavior

        // Get the href attribute (e.g., "#abstract")
        var anchor = $(this).attr('href');

        // Construct the full URL with the anchor
        var url = window.location.origin + window.location.pathname + anchor;

        // Copy the URL to the clipboard using the Clipboard API
        if (navigator.clipboard && window.isSecureContext) {
          // navigator.clipboard API method
          navigator.clipboard.writeText(url).then(function() {
            // Success feedback: Change icon to checkmark
            var $icon = $(e.currentTarget).find('i');
            $icon.removeClass('fa-link').addClass('fa-check');

            // Revert back to the original icon after 2 seconds
            setTimeout(function() {
              $icon.removeClass('fa-check').addClass('fa-link');
            }, 2000);
          }, function(err) {
            console.error('Could not copy text: ', err);
            alert('Failed to copy the link. Please try again.');
          });
        } else {
          // Fallback method for older browsers
          var textArea = document.createElement("textarea");
          textArea.value = url;
          // Make the textarea out of viewport
          textArea.style.position = "fixed";
          textArea.style.left = "-999999px";
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          try {
            document.execCommand('copy');
            // Success feedback: Change icon to checkmark
            var $icon = $(e.currentTarget).find('i');
            $icon.removeClass('fa-link').addClass('fa-check');

            // Revert back to the original icon after 2 seconds
            setTimeout(function() {
              $icon.removeClass('fa-check').addClass('fa-link');
            }, 2000);
          } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            alert('Failed to copy the link. Please try manually.');
          }
          document.body.removeChild(textArea);
        }
      });
    });



    document.addEventListener('DOMContentLoaded', function() {
      const images = document.querySelectorAll('img');
      
      images.forEach(img => {
        // Create container
        const container = document.createElement('div');
        container.className = 'progressive-image-container';
        img.parentNode.insertBefore(container, img);
        
        // Create placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        placeholder.innerHTML = '<div class="spinner"></div>';
        container.appendChild(placeholder);
        
        // Move image into container
        container.appendChild(img);
        img.className += ' progressive-image';
        
        // Load image
        const newImg = new Image();
        newImg.src = img.src;
        newImg.onload = function() {
          img.classList.add('loaded');
          placeholder.style.display = 'none';
        };
      });
    });
  
  </script>

</body>
</html>