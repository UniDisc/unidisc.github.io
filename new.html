<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Meta tags for social media banners -->
  <meta name="description" content="UniDisc: Unified Multimodal Discrete Diffusion">
  <meta property="og:title" content="UniDisc: Unified Multimodal Discrete Diffusion"/>
  <meta property="og:description" content="UniDisc is a unified multimodal discrete diffusion model capable of jointly processing text and images for various tasks."/>
  <meta property="og:url" content="https://yourwebsite.com"/>
  <!-- Path to banner image -->
  <meta property="og:image" content="static/images/banner_image.webp" />
  <meta property="og:image:width" content="1200"/>
  <meta property="og:image:height" content="630"/>

  <meta name="twitter:title" content="UniDisc: Unified Multimodal Discrete Diffusion">
  <meta name="twitter:description" content="UniDisc is a unified multimodal discrete diffusion model capable of jointly processing text and images for various tasks.">
  <!-- Path to banner image -->
  <meta name="twitter:image" content="static/images/banner_image.webp">
  <meta name="twitter:card" content="summary_large_image">
  <!-- Keywords -->
  <meta name="keywords" content="UniDisc, Multimodal, Discrete Diffusion, Machine Learning, AI, Text Generation, Image Generation">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>UniDisc: Unified Multimodal Discrete Diffusion</title>
  <!-- <link rel="icon" type="image/x-icon" href="static/images/favicon.ico"> -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro"
  rel="stylesheet">

  <link rel="stylesheet" href="static/css/bulma.min.css">
  <link rel="stylesheet" href="static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="static/css/fontawesome.all.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="static/css/index.css">
  <style>
    .container p {
      padding-top: 1rem;
    }
    /* Add new custom column class */
    .is-five-sixths {
      flex: none;
      width: 87.5%;
    }

    html {
      scroll-behavior: smooth;
    }

    a.anchor-link {
      margin-left: 0.15em;
      color: inherit;
      text-decoration: none;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.6em;
      position: relative;
      top: -0.15em;
      cursor: pointer;
    }

    /* Show the anchor link on hover */
    h2[id]:hover a.anchor-link {
      opacity: 1;
    }

    .progressive-image-container {
      position: relative;
      overflow: hidden;
    }

    .progressive-image {
      opacity: 0;
      transition: opacity 0.3s ease-in;
    }

    .progressive-image.loaded {
      opacity: 1;
    }

    .image-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3273dc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Update the cached-sentence-builder width and layout */
    #cached-section .cached-sentence-builder {
        flex-grow: 1;
        padding: 20px;
        max-width: 420px; /* Adjusted to balance with grid container */
    }

    /* Update the current sentence display */
    #cached-section #cached-current-sentence {
        margin-top: 20px;
        padding: 15px;
        background-color: #f5f5f5;
        border-radius: 8px;
        min-height: 30px;
        font-family: monospace;
        width: 100%; /* Ensure it takes full width of its container */
        box-sizing: border-box; /* Include padding in width calculation */
        white-space: pre-wrap; /* Allow text to wrap */
        word-break: break-word; /* Break long words if needed */
    }

    /* Add styles for the response text */
    #cached-section #cached-response-text {
        margin-top: 20px;
        padding: 15px;
        background-color: #e6f7ff;
        border-radius: 8px;
        min-height: 30px;
        font-family: monospace;
        width: 100%;
        box-sizing: border-box;
        white-space: pre-wrap;
        word-break: break-word;
        display: none; /* Initially hidden */
    }

    /* Adjust the main container spacing */
    #cached-section .cached-main-container {
        display: flex;
        max-width: 1050px; /* Reduced from 1200px */
        margin: 0 auto; /* Center the container */
        gap: 40px; /* Increased from 20px for more balanced spacing */
        align-items: flex-start;
        padding: 0 20px; /* Add padding to prevent edge touching */
    }

    #cached-section .cached-grid-container {
      position: relative;
      width: 512px;
      height: 512px;
    } 
  </style>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>
  <script defer src="static/js/fontawesome.all.min.js"></script>
  <script src="static/js/bulma-carousel.min.js"></script>
  <script src="static/js/bulma-slider.min.js"></script>
  <script src="static/js/index.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

    <!-- Header Section -->
    <section class="hero">
      <div class="hero-body" style="padding-bottom: 1.5rem;">
        <div class="container is-max-desktop">
          <div class="columns is-centered">
            <div class="column has-text-centered">
              <h1 class="title is-1 publication-title">UniDisc: Unified Multimodal Discrete Diffusion</h1>
              
              <div class="is-size-5 publication-authors">
                <span class="author-block">
                      Alexander Swerdlow<sup>*</sup>,</span>
                      <span class="author-block">
                        Mihir Prabhudesai<sup>*</sup>,</span>
                      <span class="author-block">
                          Siddharth Gandhi,</span>
                      <span class="author-block">
                          Deepak Pathak,</span>
                      <span class="author-block">
                          Katerina Fragkiadaki
                </span>
                <span class="eql-cntrb"><small><br><sup>*</sup>Equal Contribution</small></span>
                </div> 
  
                  
  
                    <div class="column has-text-centered">
                      <div class="publication-links">
                        <span class="link-block">
                          <a href="static/files/UniDisc.pdf" target="_blank"
                          class="external-link button is-normal is-rounded is-dark">
                          <span class="icon">
                            <i class="fas fa-file-pdf"></i>
                          </span>
                          <span>Paper</span>
                        </a>
                      </span>
  
                      <!-- <span class="link-block">
                        <a href="static/pdfs/supplementary_material.pdf" target="_blank"
                        class="external-link button is-normal is-rounded is-dark">
                        <span class="icon">
                          <i class="fas fa-file-pdf"></i>
                        </span>
                        <span>Supplementary</span>
                      </a>
                    </span> -->
  
                    <!-- <span class="link-block">
                      <a href="https://github.com/your_repo_here" target="_blank"
                      class="external-link button is-normal is-rounded is-dark">
                      <span class="icon">
                        <i class="fab fa-github"></i>
                      </span>
                      <span>Code</span>
                    </a>
                  </span>  -->
  
                  <!-- <span class="link-block">
                    <a href="https://arxiv.org/abs/your_paper_id" target="_blank"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="ai ai-arxiv"></i>
                    </span>
                    <span>arXiv</span>
                  </a>
                </span> -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="flipping-images-section">
      <style>
        #flipping-images-section {
          font-family: sans-serif;
          margin: 2rem auto;            /* Center the section vertically */
          max-width: 100%;              /* Make it full screen width */
          padding: 0 0px;              /* Add left/right padding */
          overflow: hidden;
        }
        #flipping-images-section .flip-card-container {
          display: flex;
          flex-wrap: wrap;
          gap: 0;
          justify-content: center;
          padding: 0;
          margin: 0;
          width: 100%;
          line-height: 0; /* Eliminate whitespace between inline elements */
          font-size: 0;
        }
        #flipping-images-section .flip-card {
          background-color: transparent;
          width: 20%; /* 5 cards per row */
          aspect-ratio: 520/720; /* Match image dimensions */
          perspective: 1000px;
          cursor: pointer;
          flex: 0 0 20%;
          position: relative;
          margin: 0;
          padding: 0;
          font-size: 16px;
          vertical-align: top;
        }
        #flipping-images-section .flip-card-inner {
          position: relative;
          width: 100%;
          height: 100%;
          transition: transform 0.6s;
          transform-style: preserve-3d;
          margin: 0;
        }
        #flipping-images-section .flip-card.flipped .flip-card-inner {
          transform: rotateY(180deg);
        }
        #flipping-images-section .flip-card-front,
        #flipping-images-section .flip-card-back {
          position: absolute;
          width: 100%;
          height: 100%;
          backface-visibility: hidden;
          overflow: hidden;
          margin: 0;
          padding: 0;
        }
        #flipping-images-section .flip-card-front {
          z-index: 2;
        }
        #flipping-images-section .flip-card-back {
          transform: rotateY(180deg);
          z-index: 1;
          position: relative;
        }
        #flipping-images-section .input-label {
          position: absolute;
          top: 10px;
          left: 10px;
          background-color: rgba(0, 0, 0, 0.5);
          color: white;
          padding: 10px 8px;
          border-radius: 4px;
          font-size: 12px;
          opacity: 0.8;
          z-index: 3;
        }
        #flipping-images-section figure {
          margin: 0;
          padding: 0;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          line-height: 0;
          position: relative;
        }
        #flipping-images-section img {
          width: 100%;
          height: 100%;
          object-fit: contain; /* Changed from cover to contain */
          display: block;
          margin: 0;
          padding: 0;
          border: 0;
        }
        #flipping-images-section figcaption {
          display: block;
          padding: 8px;
          font-size: 14px;
          color: #333;
          text-align: center;
          background: #f5f5f5;
          margin: 0;
          line-height: normal;
        }
        
        /* New styles for transparent grey overlay on the *back* images */
        #flipping-images-section .back-image-container {
          position: relative;
          height: 100%;
        }
        #flipping-images-section .back-image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(128, 128, 128, 0.7); /* semi-transparent grey */
          pointer-events: none;
          z-index: 1;
        }
        /* Ensure the image sits below the overlay */
        #flipping-images-section .flip-card-back figure img {
          position: relative;
          z-index: 0;
        }
        /* Keep the caption above the overlay */
        #flipping-images-section .flip-card-back figure figcaption {
          position: relative;
          z-index: 2;
        }
      </style>
      <div class="flip-card-container"></div>
      <script>
        (function() {
          const flipCardsData = [
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.002.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.001.jpeg", 
              backCaption: ""
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.004.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.003.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.006.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.005.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.008.jpeg", 
              frontCaption: "",
              backUrl: "static/images/unidisc_main/unidisc_main.007.jpeg", 
              backCaption: "", 
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.010.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.009.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.012.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.011.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.014.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.013.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.016.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.015.jpeg", 
              backCaption: "",
            },
            {
              frontUrl: "static/images/unidisc_main/unidisc_main.018.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.017.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl:  "static/images/unidisc_main/unidisc_main.020.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.019.jpeg",
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.022.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.021.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.024.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.023.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.026.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.025.jpeg", 
              backCaption: ""
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.028.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.027.jpeg", 
              backCaption: "",
            },
            { 
              frontUrl: "static/images/unidisc_main/unidisc_main.030.jpeg", 
              frontCaption: "", 
              backUrl: "static/images/unidisc_main/unidisc_main.029.jpeg", 
              backCaption: "",
            }
            // ,
            // { 
            //   frontUrl: "static/images/flipping/joint/19_f.png", 
            //   frontCaption: "", 
            //   backUrl: "static/images/flipping/joint/19_b.png", 
            //   backCaption: "",
            // }            
          ];

          // Randomize the order of flipCardsData
          flipCardsData.sort(() => Math.random() - 0.5);
          const container = document.querySelector('#flipping-images-section .flip-card-container');
          
          flipCardsData.forEach(card => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'flip-card';
            cardDiv.innerHTML = `
              <div class="flip-card-inner">
                <div class="flip-card-front">
                  <figure>
                    <img src="${card.frontUrl}" alt="Front Image">
                    ${card.frontCaption ? `<figcaption>${card.frontCaption}</figcaption>` : ''}
                  </figure>
                </div>
                <div class="flip-card-back">
                  <span class="input-label">Input</span>
                  <figure>
                    <div class="back-image-container">
                      <img src="${card.backUrl}" alt="Back Image">
                      <div class="back-image-overlay"></div>
                    </div>
                    ${card.backCaption ? `<figcaption>${card.backCaption}</figcaption>` : ''}
                  </figure>
                </div>
              </div>
            `;
            container.appendChild(cardDiv);
          });
          
          function initFlipCards() {
            const flipCards = document.querySelectorAll('#flipping-images-section .flip-card');
            flipCards.forEach(card => {
              card.addEventListener('click', () => {
                card.classList.toggle('flipped');
              });
            });
          }
          
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initFlipCards);
          } else {
            initFlipCards();
          }
          
          // Automatic random flipping logic
          (function autoFlip() {
            const flipCards = Array.from(document.querySelectorAll('#flipping-images-section .flip-card'));
            function randomFlipCard() {
              if (flipCards.length === 0) return;
              const randomIndex = Math.floor(Math.random() * flipCards.length);
              const card = flipCards[randomIndex];
              card.classList.toggle('flipped');
              setTimeout(randomFlipCard, 3000);
            }
            setTimeout(randomFlipCard, 3000);
          })();
        })();
      </script>
    </section>

  <!-- Teaser Image -->
  <!-- <section class="hero teaser">
    <div class="container is-max-desktop">
      <div class="hero-body">
        <picture>
          <source srcset="static/images/main_fidelity.webp" type="image/webp">
          <img src="static/images/main_fidelity.webp" alt="Joint Inpainting">
        </picture>
        <h2 class="subtitle has-text-centered">
        <div style="margin-top: 10px;">
          UniDisc jointly inpainting unseen image-text pairs. This ability is not possible with prior models such as T2I diffusion or AR models.
        </div>
        </h2>
      </div>
    </div>
  </section> -->

  <!-- Abstract -->
  <section class="section hero is-light">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-centered">
        <div class="column is-four-fifths">
          <h2 id="abstract" class="title is-3">Abstract
            <a href="#abstract" class="anchor-link">
              <i class="fas fa-link"></i>
            </a>
          </h2>
          <div class="content has-text-justified">
            <p>
              Multimodal generative models that can understand and generate across multiple modalities are dominated by autoregressive (AR) approaches, which process tokens sequentially from left to right, or top to bottom. These models jointly handle images, text, video, and audio for various tasks such as image captioning, question answering, and image generation. While AR models have been highly successful in the text domain, they have been found suboptimal for processing images, videos, and audio due to the high correlation between adjacent tokens which waste inference-time compute by separately predicting each one. In this work, we explore discrete diffusion models as a unified generative formulation in the joint text and image domain, building upon their recent success in the text domain alone. Discrete diffusion models offer several advantages over AR models, including improved control over quality versus diversity of generated samples, the ability to perform joint multimodal inpainting (across both text and image domains), and greater controllability in generation through guidance. Leveraging these benefits, we present the first <strong>Uni</strong>fied Multimodal <strong>Disc</strong>rete Diffusion (UniDisc) model, which is capable of jointly processing text and images for a variety of downstream tasks. We compare UniDisc to multimodal AR models of similar capacity, demonstrating that UniDisc outperforms them in terms of both performance and inference-time compute, enhanced controllability, editability, inpainting, and flexible trade-off of inference time versus generation quality.
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>
<!-- 
  <section class="hero is-small">
    <div class="hero-body">
      <div class="container">
        <div id="results-carousel" class="carousel results-carousel">
        <div class="item">
          <img src="static/images/architecture_diagram.webp" alt="MY ALT TEXT" style="padding-bottom: 20px;"/>
          <h2 class="subtitle has-text-centered">
            UniDisc's architecture.
          </h2>
        </div>
        <div class="item">
          <img src="static/images/modality_plot.webp" alt="MY ALT TEXT"/>
          <h2 class="subtitle has-text-centered">
            UniDisc's modality plot.
          </h2>
        </div>
        <div class="item">
          <img src="static/images/carousel3.jpg" alt="MY ALT TEXT"/>
          <h2 class="subtitle has-text-centered">
          Third image description.
        </h2>
      </div>
      <div class="item">
        <img src="static/images/carousel4.jpg" alt="MY ALT TEXT"/>
        <h2 class="subtitle has-text-centered">
          Fourth image description.
        </h2>
      </div>
    </div>
  </div>
  </div>
  </section> -->

  <!-- TODO: Remove. -->
  <div id="dev-url-selector" style="text-align: center; margin-bottom: 10px; padding: 10px; background-color: #f8f8f8; border-radius: 4px;">
    <span style="font-size: 12px; color: #666;">SERVER: </span>
    <button id="prod-server-btn" class="button is-small is-primary">Older</button>
    <button id="dev-server-btn" class="button is-small">Newer</button>
  </div>

  <!-- cached-section starts here -->
  <section id="cached-section" class="section">
    <style>
      /* Scoped styles for the cached section */
      #cached-section {
        font-family: Arial, sans-serif;
      }
      /* Restore bolder text for headers and word options */
      #cached-section h2,
      #cached-section .cached-word-option {
        font-weight: 700;
      }
      #cached-section .cached-main-container {
        display: flex;
        max-width: 1050px; /* Reduced from 1200px */
        margin: 0 auto; /* Center the container */
        gap: 40px; /* Increased from 20px for more balanced spacing */
        align-items: flex-start;
        padding: 0 20px; /* Add padding to prevent edge touching */
      }
      #cached-section .cached-left-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      #cached-section .cached-grid-container {
        position: relative;
        width: 512px;
        height: 512px;
      }
      #cached-section .cached-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      #cached-section .cached-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
      }
      #cached-section .cached-grid-cell {
        border: 1px solid black;
        transition: background-color 0.1s ease;
      }
      #cached-section .cached-highlighted {
        background-color: rgba(128, 128, 128, 0.9);
      }
      #cached-section .cached-sentence-builder {
        flex-grow: 1;
        padding: 20px;
        max-width: 500px; /* Add max-width to constrain the builder section */
      }
      #cached-section .cached-sentence-row {
        margin: 15px 0;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
      }
      #cached-section .cached-word-option {
        padding: 12px 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #666;
        border-radius: 4px;
        font-weight: 600;
        background: #f5f5f5;
      }
      #cached-section .cached-word-option:hover {
        color: #000;
        font-weight: 600;
        background: #e5e5e5;
      }
      #cached-section .cached-word-option.cached-selected {
        color: #886a6a;
        font-weight: 600;
        background: #e0e0e0;
      }
      #cached-section #cached-current-sentence {
        margin-top: 20px;
        padding: 15px;
        background-color: #f5f5f5;
        border-radius: 8px;
        min-height: 30px;
        font-family: monospace;
        width: 100%; /* Ensure it takes full width of its container */
        box-sizing: border-box; /* Include padding in width calculation */
        white-space: pre-wrap; /* Allow text to wrap */
        word-break: break-word; /* Break long words if needed */
      }
    </style>

    <!-- HTML content for cached.html with namespaced IDs/classes -->
    <div class="cached-main-container">
      <div class="cached-left-container">
        <div class="cached-grid-container">
          <img src="static/images/fergus.png" alt="Grid Image" class="cached-image">
          <div id="cached-grid" class="cached-grid">
          </div>
        </div>
      </div>

      <div class="cached-sentence-builder">
        <h2>Build your sentence:</h2>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="0" data-word="the playful">the playful</span>
          <span class="cached-word-option" data-row="0" data-word="a curious">a curious</span>
          <span class="cached-word-option" data-row="0" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="1" data-word="little cat">little cat</span>
          <span class="cached-word-option" data-row="1" data-word="happy puppy">happy puppy</span>
          <span class="cached-word-option" data-row="1" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="2" data-word="is always">is always</span>
          <span class="cached-word-option" data-row="2" data-word="was just">was just</span>
          <span class="cached-word-option" data-row="2" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="3" data-word="having fun">having fun</span>
          <span class="cached-word-option" data-row="3" data-word="playing around">playing around</span>
          <span class="cached-word-option" data-row="3" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="4" data-word="in the">in the</span>
          <span class="cached-word-option" data-row="4" data-word="near the">near the</span>
          <span class="cached-word-option" data-row="4" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div class="cached-sentence-row">
          <span class="cached-word-option" data-row="5" data-word="cozy home">cozy home</span>
          <span class="cached-word-option" data-row="5" data-word="sunny park">sunny park</span>
          <span class="cached-word-option" data-row="5" data-word="&lt;mask&gt;">&lt;mask&gt;</span>
        </div>
        <div id="cached-current-sentence">Click word pairs above to build your sentence!</div>
        <div id="cached-response-text"></div>
      </div>
    </div>

    <script>
      (() => {

        let API_URL = "https://rerun.aswerdlow.com/v1/chat/completions"; // Production URL
        const DEV_API_URL = "https://grafana.aswerdlow.com/v1/chat/completions"; // Dev URL
        
        // Add URL selector functionality
        const devUrlSelector = document.getElementById('dev-url-selector');
        const prodServerBtn = document.getElementById('prod-server-btn');
        const devServerBtn = document.getElementById('dev-server-btn');
        
        // Only initialize if the elements exist (for easy disabling)
        if (devUrlSelector && prodServerBtn && devServerBtn) {
          prodServerBtn.addEventListener('click', () => {
            API_URL = API_URL;
            prodServerBtn.classList.add('is-primary');
            devServerBtn.classList.remove('is-primary');
            console.log("Using production server:", API_URL);
          });
          
          devServerBtn.addEventListener('click', () => {
            API_URL = DEV_API_URL;
            devServerBtn.classList.add('is-primary');
            prodServerBtn.classList.remove('is-primary');
            console.log("Using development server:", API_URL);
          });
        }

        const HARDCODED_CONFIG = {
            temperature: 0.9,
            top_p: 0.95,
            maskgit_r_temp: 4.5,
            cfg: 2.5,
            max_tokens: 32,
            resolution: 512,
            sampling_steps: 32,
            sampler: "maskgit_nucleus",
            use_reward_models: false
        };

        const GRID_SIZE = 8; // GRID_SIZE x GRID_SIZE.
        const MASK_SIZE = 5; // Change this number for a different mask size.
        
        // --- Utility functions ---
        async function processImage(imageBytes) {
            const img = await createImageBitmap(new Blob([imageBytes], { type: 'image/jpeg' }));
            const canvas = squareCrop(img);
            return canvas.convertToBlob({ quality: 0.95, type: 'image/jpeg' });
        }
        
        function squareCrop(img) {
            const size = Math.min(img.width, img.height);
            const canvas = new OffscreenCanvas(size, size);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img,
                (img.width - size) / 2, (img.height - size) / 2, size, size,
                0, 0, size, size
            );
            return canvas;
        }
        
        function encodeMask(maskArray) {
            const rows = maskArray.length;
            const cols = maskArray[0].length;
            const canvas = document.createElement('canvas');
            canvas.width = cols;
            canvas.height = rows;
            const ctx = canvas.getContext('2d');
        
            const imageData = ctx.createImageData(cols, rows);
            maskArray.flat().forEach((val, i) => {
                const color = val ? 255 : 0;
                imageData.data[i * 4]     = color;
                imageData.data[i * 4 + 1] = color;
                imageData.data[i * 4 + 2] = color;
                imageData.data[i * 4 + 3] = color;
            });
            ctx.putImageData(imageData, 0, 0);
        
            const dataURL = canvas.toDataURL("image/png");
            return {
                data: dataURL.split(',')[1],
                width: cols,
                height: rows
            };
        }
        
        async function callUnidiscAPI(imageBlob, maskArray, sentence) {
            // Replace <mask> with <m> for API call
            const apiSentence = sentence.replace(/<mask>/g, "<m>");
            
            console.log("Called API with sentence: ", apiSentence);
            const messages = [{
                role: "user",
                content: [
                    { type: "text", text: apiSentence }
                ]
            }];
        
            // Check if we need to include the image and mask
            const hasMaskedText = apiSentence.includes("<m>");
            const hasMaskedImage = maskArray && maskArray.some(row => row.some(cell => cell === true));
            
            // Only include image and mask if needed
            if (hasMaskedText || hasMaskedImage) {
                const resizedImage = await processImage(await imageBlob.arrayBuffer());
                const imageBase64 = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(resizedImage);
                });
                messages[0].content.push({
                    type: "image_url",
                    image_url: { url: imageBase64 },
                    is_mask: false
                });
        
                if (maskArray) {
                    const maskData = encodeMask(maskArray);
                    messages[0].content.push({
                        type: "image_url",
                        image_url: {
                            url: `data:image/png;base64,${maskData.data}`,
                            mask_info: JSON.stringify({
                                width: maskData.width,
                                height: maskData.height
                            })
                        },
                        is_mask: true
                    });
                }
            }
        
            const payload = {
                messages,
                model: "unidisc",
                ...HARDCODED_CONFIG
            };
        
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'POST, OPTIONS',
                        'Access-Control-Allow-Headers': 'Content-Type'
                    },
                    body: JSON.stringify(payload)
                });
        
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }
        
        // --- Begin cached section-specific code ---
        const section = document.getElementById('cached-section');
        const grid = section.querySelector('#cached-grid');
        const currentSentence = section.querySelector('#cached-current-sentence');
        const cells = [];
        let currentRow = 0;
        let currentCol = 0;
        let maskLocked = false; // Add this flag to track if mask is locked in place
        let activeMask = null; // Track the currently active mask coordinates
        
        // Create grid cells based on GRID_SIZE.
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cell = document.createElement('div');
            cell.className = 'cached-grid-cell';
            cell.dataset.row = Math.floor(i / GRID_SIZE);
            cell.dataset.col = i % GRID_SIZE;
            grid.appendChild(cell);
            cells.push(cell);
        }
        
        // Update highlighted grid region.
        function highlightCells(row, col) {
            // If mask is locked, don't update highlights on mousemove
            if (maskLocked) return;
            
            cells.forEach(cell => cell.classList.remove('cached-highlighted'));
            const offset = Math.floor(MASK_SIZE / 2);
            const topLeftRow = Math.min(Math.max(row - offset, 0), GRID_SIZE - MASK_SIZE);
            const topLeftCol = Math.min(Math.max(col - offset, 0), GRID_SIZE - MASK_SIZE);
            currentRow = topLeftRow + offset;
            currentCol = topLeftCol + offset;
        
            for (let r = topLeftRow; r < topLeftRow + MASK_SIZE; r++) {
                for (let c = topLeftCol; c < topLeftCol + MASK_SIZE; c++) {
                    const cell = cells[r * GRID_SIZE + c];
                    if (cell) {
                        cell.classList.add('cached-highlighted');
                    }
                }
            }
        }
        
        const selectedWords = new Array(6).fill(null);
        
        // Add default selections
        const defaultSelections = [
            "the playful",
            "happy puppy",
            "is always",
            "playing around",
            "in the",
            "sunny park"
        ];

        // Initialize with default selections
        defaultSelections.forEach((word, index) => {
            selectedWords[index] = word;
            const wordElement = section.querySelector(`.cached-word-option[data-row="${index}"][data-word="${word}"]`);
            if (wordElement) {
                wordElement.classList.add('cached-selected');
            }
        });
        
        updateSentence();
        
        section.querySelectorAll('.cached-word-option').forEach(word => {
            word.addEventListener('click', async () => {
                const row = parseInt(word.dataset.row);
                const wordText = word.dataset.word;
        
                section.querySelectorAll(`.cached-word-option[data-row="${row}"]`)
                       .forEach(w => w.classList.remove('cached-selected'));
        
                word.classList.add('cached-selected');
                selectedWords[row] = wordText;
        
                updateSentence();
                
                // Call API directly without requiring a mask
                try {
                    await updateImage();
                } catch (error) {
                    console.error('Error updating image after text change:', error);
                }
            });
        });
        
        function updateSentence() {
            const words = selectedWords.filter(word => word !== null);
            const finalWords = words.length > 0 ? words : defaultSelections;
            let sentence = finalWords[0] || '';
            for (let i = 1; i < finalWords.length; i++) {
                const joiner = (finalWords[i] === '<mask>' || finalWords[i - 1] === '<mask>') ? '<mask>' : ' ';
                sentence += joiner + finalWords[i];
            }
            currentSentence.textContent = sentence + '.';
        }
        
        grid.addEventListener('mousemove', (e) => {
            const rect = grid.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor((x / rect.width) * GRID_SIZE);
            const row = Math.floor((y / rect.height) * GRID_SIZE);
            highlightCells(row, col);
        });
        
        async function updateImage() {
            try {
                const img = section.querySelector('.cached-image');
                const currentSentence = section.querySelector('#cached-current-sentence');
                const responseText = section.querySelector('#cached-response-text');

                let maskArray = null;
                
                // Only create a mask if we have an active mask
                if (activeMask) {
                    const [topLeftRow, topLeftCol] = activeMask;
                    maskArray = Array.from({ length: GRID_SIZE }, () =>
                        Array(GRID_SIZE).fill(false)
                    );
                    for (let r = topLeftRow; r < topLeftRow + MASK_SIZE; r++) {
                        for (let c = topLeftCol; c < topLeftCol + MASK_SIZE; c++) {
                            maskArray[r][c] = true;
                        }
                    }
                }
        
                const sentence = currentSentence.textContent
                const imageBlob = await fetch(img.src).then(res => res.blob());
                
                // Show loading state
                currentSentence.style.display = 'none';
                responseText.style.display = 'block';
                responseText.textContent = 'Processing your request...';
                
                const response = await callUnidiscAPI(imageBlob, maskArray, sentence);

                const message = response.choices?.[0]?.message;
                if (!message) {
                    throw new Error("No message found in the API response");
                }

                // Extract text content if available
                let textContent = '';
                if (Array.isArray(message.content)) {
                    const textPart = message.content.find(part => part.type === "text");
                    if (textPart && textPart.text) {
                        textContent = textPart.text;
                    }
                } else if (typeof message.content === 'string') {
                    textContent = message.content;
                }

                // Update response text
                if (textContent) {
                    responseText.textContent = textContent;
                } else {
                    responseText.textContent = 'Image updated successfully!';
                }

                // Check if there's an image in the response
                let imageUrl = null;
                if (Array.isArray(message.content)) {
                    const imagePart = message.content.find(part => part.type === "image_url");
                    if (imagePart && imagePart.image_url && imagePart.image_url.url) {
                        imageUrl = imagePart.image_url.url;
                    }
                } else if (message.image_url && message.image_url.url) {
                    imageUrl = message.image_url.url;
                }

                // Only update the image if we received a new one
                if (imageUrl) {
                    const newImageUrl = imageUrl.startsWith("data:image/jpeg;base64,")
                        ? imageUrl
                        : `data:image/jpeg;base64,${imageUrl}`;
                    img.src = newImageUrl;
                }

                // Always show the response text if we have it
                if (textContent) {
                    responseText.style.display = 'block';
                    currentSentence.style.display = 'none';
                } else {
                    // If no text response, show the current sentence again
                    responseText.style.display = 'none';
                    currentSentence.style.display = 'block';
                }
                
                // Reset the mask state after getting response
                maskLocked = false;
                activeMask = null;
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));

            } catch (error) {
                console.error('Image update failed:', error);
                const responseText = section.querySelector('#cached-response-text');
                responseText.textContent = 'Error: ' + error.message;
                responseText.style.display = 'block';
                section.querySelector('#cached-current-sentence').style.display = 'none';
            }
        }
        
        grid.addEventListener('click', async () => {
            const offset = Math.floor(MASK_SIZE / 2);
            // Compute the top-left coordinate of the mask ensuring it stays within grid bounds.
            const safeTopLeftRow = Math.min(Math.max(currentRow - offset, 0), GRID_SIZE - MASK_SIZE);
            const safeTopLeftCol = Math.min(Math.max(currentCol - offset, 0), GRID_SIZE - MASK_SIZE);
            
            if (maskLocked && 
                activeMask && 
                activeMask[0] === safeTopLeftRow && 
                activeMask[1] === safeTopLeftCol) {
                // If clicking on the same mask area, unlock it
                maskLocked = false;
                activeMask = null;
                // Clear highlights
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
            } else {
                // Lock the mask at current position
                maskLocked = true;
                activeMask = [safeTopLeftRow, safeTopLeftCol];
                
                // Ensure the mask area is properly highlighted
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
                for (let r = safeTopLeftRow; r < safeTopLeftRow + MASK_SIZE; r++) {
                    for (let c = safeTopLeftCol; c < safeTopLeftCol + MASK_SIZE; c++) {
                        const cell = cells[r * GRID_SIZE + c];
                        if (cell) {
                            cell.classList.add('cached-highlighted');
                        }
                    }
                }
            }
        
            try {
                await updateImage();
            } catch (error) {
                console.error('Error updating image:', error);
            }
        });
        
        grid.addEventListener('mouseleave', () => {
            // Only clear highlights if mask is not locked
            if (!maskLocked) {
                cells.forEach(cell => cell.classList.remove('cached-highlighted'));
            }
        });
        
        // Initialize highlighting with default values.
        highlightCells(1, 1);
      })();
    </script>
  </section>

  <section class="hero is-small pt-6 pb-3">
    <div class="hero-body">
      <div class="container">
        <h2 id="overall_architecture" class="title is-3 has-text-centered">
          UniDisc Overview
          <a href="#overall_architecture" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="padding-top: 20px;">
          <div class="column is-five-sixths has-text-centered">
            <picture>
              <source srcset="static/images/unidisc_diagram_v1_crop.webp" type="image/webp">
              <img src="static/images/unidisc_diagram_v1_crop.webp" alt="Modality Plot">
            </picture>
            <p style="padding-bottom: 30px;">UniDisc is a unified multimodal discrete diffusion model that can jointly process and generate text and images. First, each modality is converted into a sequnece of discrete tokens and we randomly replace a subset of these tokens with the [MASK] token according to a noise schedule and denoted in the figure with grey boxes. We jointly denoise the image and text and supervise with a weighted cross-entropy loss. At inference time we begin with a set of [MASK] tokens and iteratively unmask tokens.</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="hero is-small is-light pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="zero_shot_editing" class="title is-3 has-text-centered">
          Zero-shot Multimodal Editing w/UniDisc
          <a href="#zero_shot_editing" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
      </div>
    </div>
  </section>

  <section class="hero is-small is-light pt-4 pb-6">
    <div class="hero-body">
      <div class="container">
        <!-- Paper video. -->
        <h2 id="multimodal_caching" class="title is-3 has-text-centered">
          Multimodal Caching
          <a href="#multimodal_caching" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>

        <div class="columns is-centered">
          <div class="column is-three-fifths has-text-centered">
            <picture>
              <source srcset="static/images/modality_plot.webp" type="image/webp">
              <img src="static/images/modality_plot.webp" alt="Modality Plot">
            </picture>
            <p style="padding-bottom: 30px;">To take advantage of this, we design a novel multimodal caching mechanism that allows UniDisc to reuse the same denoising steps for specific modalities, reducing overall inference time.</p>
            <picture>
              <source srcset="static/images/architecture_diagram.webp" type="image/webp">
              <img src="static/images/architecture_diagram.webp" alt="Text Generation from Image">
            </picture>
            <p>We maintain different noising schedules for image and text tokens, effectively setting a larger \(dt_{\text{image}}\) and a smaller \(dt_{\text{text}}\).</p>
          </div>
        </div>
        
      </div>
    </div>
  </section>


  <section class="hero is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="generation_analysis" class="title is-3 has-text-centered">
          Generation Analysis
          <a href="#generation_analysis" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="margin-top: 2rem;">
          <div class="column is-five-sixths has-text-centered">
            <picture>
              <source srcset="static/images/denoising_viz.webp" type="image/webp">
              <img src="static/images/denoising_viz.webp" alt="Joint Infilling">
            </picture>
            <p>Intermediate Steps during Joint Infilling of Image and Text. UniDisc jointly infills both image and text during generation.</p>
          </div>
        </div>

        <div class="columns is-centered" style="margin-top: 3rem;">
          <div class="column is-five-sixths has-text-centered">
            <h3 class="subtitle" style="margin-bottom: 2.0rem;">Uniform Concept Generation</h3>
            <picture>
              <source srcset="static/images/seg_viz_v2.webp" type="image/webp">
              <img src="static/images/seg_viz_v2.webp" alt="Concept Generation">
            </picture>
            <p>To quantitatively analyze the generation order, we use an language-grounded segmentation model (Grounded SAM 2) to segment the image given the text prompt. We then record the order of token decoding when using confidence-based sampling and plot the progression of each region. We observe that the model generates uniformly over concepts and modalities. In AR this is not possible as the model must generate in a specific order (e.g., text first, then raster-order), and thus the model cannot jointly reason over modalities and multiple parts of the image.</p>
          </div>
        </div>

      </div>
    </div>
  </section>



  <section class="hero is-small is-light pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="cfg_ablation" class="title is-3 has-text-centered">
          Classifier-Free Guidance Ablation
          <a href="#cfg_ablation" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="columns is-centered" style="margin-top: 2rem;">
          <div class="column is-five-sixths has-text-centered">
            <div style="display: flex; justify-content: center; gap: 1px;">
              <picture>
                <source srcset="static/images/cfg_fid.webp" type="image/webp">
                <img src="static/images/cfg_fid.webp" alt="Concept Generation" style="width: 95%;">
              </picture>
              <picture>
                <source srcset="static/images/cfg_clip_score.webp" type="image/webp">
                <img src="static/images/cfg_clip_score.webp" alt="Concept Generation" style="width: 95%;"> 
              </picture>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section class="hero is-small pt-5 pb-6">
    <div class="hero-body">
      <div class="container">
        <h2 id="cfg_unidisc_ar_analysis" class="title is-3 has-text-centered">
          Classifier-Free Guidance Analysis
          <a href="#cfg_unidisc_ar_analysis" class="anchor-link">
            <i class="fas fa-link"></i>
          </a>
        </h2>
        <div class="column is-five-sixths has-text-centered">
          <p style="margin-bottom: 3rem; margin-top: -3.0rem;">L2 distance between unconditional and conditional logits over the course of generation.</p>
        </div>
        <div class="columns is-centered">
          <div class="column is-five-sixths has-text-centered">
            <h3 class="subtitle">Qualitative Effect of Classifier-Free Guidance</h3>
            <picture>
              <source srcset="static/images/cfg_v3.webp" type="image/webp">
              <img src="static/images/cfg_v3.webp" alt="Classifier-Free Guidance" style="margin-bottom: -0.6rem;">
            </picture>
            <p style="margin-bottom: -0.8rem;">Effect of classifier-free guidance on UniDisc, from left to right, starting with \(w=0\), increasing to \(w=8\).</p>
            <p>Caption: <i>Crab meditating, surfboard, orange sun setting, rainbow clouds, zen beach.</i></p>
          </div>
        </div>
      </div>
    </div>
  </section>

    <!-- BibTeX Citation -->
  <section class="section" id="BibTeX">
    <div class="container is-max-desktop content">
      <h2 class="title">BibTeX</h2>
      <pre><code>@article{your_citation_key,
      title={UniDisc: Unified Multimodal Discrete Diffusion},
      author={First Author and Second Author and Third Author},
      journal={Conference Name},
      year={2023}
      }</code></pre>
        </div>
    </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="columns is-centered">
        <div class="column is-8">
          <div class="content">
  
            <p>
              This page was built using the <a href="https://github.com/eliahuhorwitz/Academic-project-page-template" target="_blank">Academic Project Page Template</a> which was adopted from the <a href="https://nerfies.github.io" target="_blank">Nerfies</a> project page. This website is licensed under a <a rel="license"  href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative
              Commons Attribution-ShareAlike 4.0 International License</a>.
            </p>
  
          </div>
        </div>
      </div>
    </div>
  </footer>


  <!-- Good lazy loading with animation. For some reason, adding this conflicts with <picture> which is needed to optionally load webp images so for now we add the lazy load attribute (which should be removed when using the below code.) -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Ensure that we wait for all images to be loaded before scrolling to hash
        const images = document.querySelectorAll('img');

        let imagesLoaded = 0;
        const totalImages = images.length;

        images.forEach((img) => {
          if (img.complete) {
            imagesLoaded++;
          } else {
            img.addEventListener('load', function() {
              imagesLoaded++;
              if (imagesLoaded === totalImages) {
                scrollToHash();
              }
            });
            img.addEventListener('error', function() {
              imagesLoaded++;
              if (imagesLoaded === totalImages) {
                scrollToHash();
              }
            });
          }
        });

        // If no images or all images are already loaded
        if (totalImages === 0 || imagesLoaded === totalImages) {
          scrollToHash();
        }

        function scrollToHash() {
          const hash = window.location.hash;
          if (hash) {
            // Use setTimeout to ensure scroll happens after all content is visible
            setTimeout(() => {
              const target = document.querySelector(hash);
              if (target) {
                target.scrollIntoView({ behavior: 'smooth' });
              }
            }, 100);
          }
        }
      });

    $(document).ready(function() {
      $('a.anchor-link').on('click', function(e) {
        e.preventDefault(); // Prevent the default anchor behavior

        // Get the href attribute (e.g., "#abstract")
        var anchor = $(this).attr('href');

        // Construct the full URL with the anchor
        var url = window.location.origin + window.location.pathname + anchor;

        // Copy the URL to the clipboard using the Clipboard API
        if (navigator.clipboard && window.isSecureContext) {
          // navigator.clipboard API method
          navigator.clipboard.writeText(url).then(function() {
            // Success feedback: Change icon to checkmark
            var $icon = $(e.currentTarget).find('i');
            $icon.removeClass('fa-link').addClass('fa-check');

            // Revert back to the original icon after 2 seconds
            setTimeout(function() {
              $icon.removeClass('fa-check').addClass('fa-link');
            }, 2000);
          }, function(err) {
            console.error('Could not copy text: ', err);
            alert('Failed to copy the link. Please try again.');
          });
        } else {
          // Fallback method for older browsers
          var textArea = document.createElement("textarea");
          textArea.value = url;
          // Make the textarea out of viewport
          textArea.style.position = "fixed";
          textArea.style.left = "-999999px";
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          try {
            document.execCommand('copy');
            // Success feedback: Change icon to checkmark
            var $icon = $(e.currentTarget).find('i');
            $icon.removeClass('fa-link').addClass('fa-check');

            // Revert back to the original icon after 2 seconds
            setTimeout(function() {
              $icon.removeClass('fa-check').addClass('fa-link');
            }, 2000);
          } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            alert('Failed to copy the link. Please try manually.');
          }
          document.body.removeChild(textArea);
        }
      });
    });


    document.addEventListener('DOMContentLoaded', function() {
      const images = document.querySelectorAll('img');
      
      images.forEach(img => {
        // Create container
        const container = document.createElement('div');
        container.className = 'progressive-image-container';
        img.parentNode.insertBefore(container, img);
        
        // Create placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'image-placeholder';
        placeholder.innerHTML = '<div class="spinner"></div>';
        container.appendChild(placeholder);
        
        // Move image into container
        container.appendChild(img);
        img.className += ' progressive-image';
        
        // Load image
        const newImg = new Image();
        newImg.src = img.src;
        newImg.onload = function() {
          img.classList.add('loaded');
          placeholder.style.display = 'none';
        };
      });
    });
  </script>

</body>
</html>